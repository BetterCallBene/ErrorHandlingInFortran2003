<?xml version="1.0"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:exsl="http://exslt.org/common" xmlns:str="http://exslt.org/strings">
    <xsl:output omit-xml-declaration="yes"  method="text"/>
    
    <!-- MAIN -->
    
    <xsl:template match="wrappers">
<xsl:text/>! ERROR_HANDLING_COMMON_WRAPPERS
! 
!   Collection of wrapper arround commonly used intrinsic routines that need
!   to check some condition.
! 
! HISTORY
! 
!   20110411 KP - Initial version
!   <xsl:value-of select="$isoD"/> (KP) - Re-generated (make autogenerated)
! 
! AUTHOR
! 
!   Koen Poppe, Department of Computer Science,
!   Katholieke Universiteit Leuven, Celestijnenlaan 200A,
!   B-3001 Heverlee, Belgium
!   Email:  Koen.Poppe@cs.kuleuven.be
!
module error_handling_common_wrappers
    use error_handling_error
    use error_handling_common_errors
    implicit none
    private
    save
<xsl:text/>

<xsl:call-template name="interfaces"/>

contains
<xsl:call-template name="procedures"/>

end module error_handling_common_wrappers
    </xsl:template>
    
    <!-- TEMPLATES -->
    
    <xsl:template match="allocate">
        <xsl:param name="version"/>
		<xsl:param name="extra" select="@extra"/>
		<xsl:choose>
			<xsl:when test="$extra = 'size'">
			
        <xsl:for-each select="exsl:node-set($version)">
            <xsl:variable name="rank"><xsl:value-of select="@rank"/></xsl:variable>
    subroutine <xsl:call-template name="name-mangler"/>( array, sizes, ifail )
        <xsl:value-of select="@type"/><xsl:call-template name="rank-specification"/>, allocatable, intent(out) :: array
        integer<xsl:call-template name="rank-dimension"/>, intent(in) :: sizes
        type(error), intent(out), optional :: ifail
        integer :: stat, i
        allocate( array( <xsl:text/><xsl:choose>
            <xsl:when test="@rank = 1">
                <xsl:text/>sizes<xsl:text/>
            </xsl:when>
            <xsl:otherwise>
<xsl:text/><xsl:for-each select="exsl:node-set($counter)/*[. &lt;= $rank]"><xsl:if test=". &gt; 1 ">,</xsl:if> <xsl:text>sizes(</xsl:text><xsl:value-of select="."/><xsl:text>)</xsl:text></xsl:for-each></xsl:otherwise>
        </xsl:choose>
        <xsl:text/> ), stat=stat )
        if( stat /= 0 ) then
            call create_error( ifail, &amp;
#ifdef FC_NO_DT_CONSTRUCTOR
                allocation_error_constructor( &amp;
#else
                allocation_error( &amp;
#endif
                 stat, (/ ( 1, i=1, <xsl:value-of select="@rank"/> ) /), <xsl:if test="@rank = 1">(/ </xsl:if>sizes<xsl:if test="@rank = 1"> /)</xsl:if> ) )
        end if
    end subroutine <xsl:call-template name="name-mangler"/>
        </xsl:for-each>
		
			</xsl:when>
			<xsl:when test="$extra = 'lowerupper'">
				
        <xsl:for-each select="exsl:node-set($version)">
            <xsl:variable name="rank"><xsl:value-of select="@rank"/></xsl:variable>
    subroutine <xsl:call-template name="name-mangler"/>( array, lower, upper, ifail )
        <xsl:value-of select="@type"/><xsl:call-template name="rank-specification"/>, allocatable, intent(out) :: array
        integer<xsl:call-template name="rank-dimension"/>, intent(in) :: lower, upper
        type(error), intent(out), optional :: ifail
        integer :: stat
        allocate( array( <xsl:text/><xsl:choose>
            <xsl:when test="@rank = 1">
                <xsl:text/>lower:upper<xsl:text/>
            </xsl:when>
            <xsl:otherwise>
<xsl:text/><xsl:for-each select="exsl:node-set($counter)/*[. &lt;= $rank]"><xsl:if test=". &gt; 1 ">,</xsl:if> <xsl:text>lower(</xsl:text><xsl:value-of select="."/><xsl:text>):upper(</xsl:text><xsl:value-of select="."/><xsl:text>)</xsl:text></xsl:for-each></xsl:otherwise>
        </xsl:choose>
        <xsl:text/> ), stat=stat )
        if( stat /= 0 ) then
            call create_error( ifail, &amp;
#ifdef FC_NO_DT_CONSTRUCTOR
                allocation_error_constructor( &amp;
#else
                allocation_error( &amp;
#endif
                 stat, <xsl:if test="@rank = 1">(/ </xsl:if>lower<xsl:if test="@rank = 1"> /)</xsl:if>, <xsl:if test="@rank = 1">(/ </xsl:if>upper<xsl:if test="@rank = 1"> /)</xsl:if> ) )
        end if
    end subroutine <xsl:call-template name="name-mangler"/>
        </xsl:for-each>
				
			</xsl:when>
		</xsl:choose>
		
		
    </xsl:template>
    <xsl:template match="lazy_allocate">
        <xsl:param name="version"/>
		<xsl:param name="extra" select="@extra"/>
		<xsl:choose>
			<xsl:when test="$extra = 'size'">
		
        <xsl:for-each select="exsl:node-set($version)">
            <xsl:variable name="rank"><xsl:value-of select="@rank"/></xsl:variable>
    subroutine <xsl:call-template name="name-mangler"/>( array, sizes, ifail )
        <xsl:value-of select="@type"/><xsl:call-template name="rank-specification"/>, allocatable, intent(in out) :: array
        integer<xsl:call-template name="rank-dimension"/>, intent(in) :: sizes
        type(error), intent(out), optional :: ifail
        
        if( allocated(array) ) then<xsl:text/>
		<xsl:choose>
			<xsl:when test="@rank = 1">
            if( size(array) == sizes ) then<xsl:text/>
			</xsl:when>
			<xsl:otherwise>
            if( all( shape(array) == sizes ) ) then<xsl:text/>
			</xsl:otherwise>
		</xsl:choose>
                return ! OK, no need to re-allocate
            end if
            ! Wrong shape -> re-allocate
            deallocate( array )
        end if
        call allocate( array, sizes, ifail )
    end subroutine <xsl:call-template name="name-mangler"/>
        </xsl:for-each>

			</xsl:when>
			<xsl:when test="$extra = 'lowerupper'">

        <xsl:for-each select="exsl:node-set($version)">
            <xsl:variable name="rank"><xsl:value-of select="@rank"/></xsl:variable>
    subroutine <xsl:call-template name="name-mangler"/>( array, lower, upper, ifail )
        <xsl:value-of select="@type"/><xsl:call-template name="rank-specification"/>, allocatable, intent(in out) :: array
        integer<xsl:call-template name="rank-dimension"/>, intent(in) :: lower, upper
        type(error), intent(out), optional :: ifail
        
        if( allocated(array) ) then<xsl:text/>
		<xsl:choose>
			<xsl:when test="@rank = 1">
            if( lbound(array,1) == lower .and. ubound(array,1) == upper ) then<xsl:text/>
			</xsl:when>
			<xsl:otherwise>
            if( all( lbound(array) == lower ) .and. all( ubound(array) == upper ) ) then<xsl:text/>
			</xsl:otherwise>
		</xsl:choose>
                return ! OK, no need to re-allocate
            end if
            ! Wrong shape -> re-allocate
            deallocate( array )
        end if
        call allocate( array, lower, upper, ifail )
    end subroutine <xsl:call-template name="name-mangler"/>
        </xsl:for-each>
		
			</xsl:when>
		</xsl:choose>
    </xsl:template>
    
    <xsl:include href="autogenerated.xsl"/>
    
</xsl:stylesheet>