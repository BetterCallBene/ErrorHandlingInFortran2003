! ERROR_HANDLING_unittest
! 
!   Collection of wrapper around commonly used routines that need to check 
!   some condition.
! 
! HISTORY
! 
!   20110217 KP - Initial version
!   20110412 KP - Ported to auto-generated system
!   20111107 KP - Improve reporting
!                 NOTE@self: the distinction between runtime check and unit test test is nice.
!   20111108 KP - Changing the write_to prototype proved to be a good move for the report functions
!   20111109 KP - Code cleanup and improved documentation
!               - Changed assert_equal to assert_eq to conform to the common literal names for the comparisons
!               - Added assert_XX where XX in { NE, LT, LE, GT, GE }
!   20111110 KP - Character strings are left aligned
!               - Optional fmt argument to modify the output format
!               - info%show_difference_marks allows to show/hide the difference marks
!   20111216 KP - FC_NO_ALLOCATABLE_DTCOMP compiler flag allows for compilers that do
!                 not support allocatable components in derived types
!   20120619 KP - unit_test -> unittest, write_unit_test_report -> unittest_report
!   20120724 KP - fixed handling of ifail in unittest_...
!   20120725 KP - astetics of output: remove leading spaces, ensure at least idx is shown
!   20120725 (KP) - Re-generated (make autogenerated)
! 
! AUTHOR
! 
!   Koen Poppe, Department of Computer Science,
!   Katholieke Universiteit Leuven, Celestijnenlaan 200A,
!   B-3001 Heverlee, Belgium
!   Email: Koen.Poppe@cs.kuleuven.be
!
module error_handling_unittest
    use error_handling_error
    use design_by_contract
    implicit none
    private
    save

    !--------------------------------------------------------------------------
    ! Unit testing
    !--------------------------------------------------------------------------
    
    ! Primitives
    public :: unittest_reset
    public :: unittest_results
    public :: unittest_report
    
    ! Test statistics
    integer :: OUTPUT_WIDTH = 80 ! Maximal width of the output
    integer :: ntest = -1, nfail = -1
    character(len=32) :: module_name = ""
    
    ! Error info types
    type, extends(message_error), public :: unittest_error
        
#ifndef FC_NO_ALLOCATABLE_DTCOMP
        character(:), allocatable :: statement, comment, filename
#else
        character(MAX_CHARACTER_LEN) :: statement = "", comment = "", filename = ""
#endif
        integer :: line = -1
#ifndef FC_NO_ALLOCATABLE_DTCOMP
        character(:), allocatable :: a_name,b_name,extra_name
#else
        character(MAX_CHARACTER_LEN) :: a_name = "",b_name = "",extra_name = ""
#endif
        logical :: show_difference_marks = .false.
    
    end type unittest_error

    type, extends(unittest_error) :: unittest_error_rank0
#ifndef FC_NO_ALLOCATABLE_DTCOMP
        logical :: diff
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a,b, extra
#else
        character(:), allocatable :: a,b, extra
#endif
#endif
    contains
        procedure :: write_to => unittest_error_write_to_rank0
    end type unittest_error_rank0
#ifdef FC_NO_ALLOCATABLE_DTCOMP
    logical :: unittest_error_rank0_diff
    character(len=MAX_CHARACTER_LEN) :: unittest_error_rank0_a, &
        unittest_error_rank0_b, unittest_error_rank0_extra
#endif

    type, extends(unittest_error) :: unittest_error_rank1
#ifndef FC_NO_ALLOCATABLE_DTCOMP
        logical, dimension(:), allocatable :: diff
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:), allocatable :: a,b, extra
#else
        character(:), dimension(:), allocatable :: a,b, extra
#endif
#endif
    contains
        procedure :: write_to => unittest_error_write_to_rank1
    end type unittest_error_rank1
#ifdef FC_NO_ALLOCATABLE_DTCOMP
    logical, dimension(:), allocatable :: unittest_error_rank1_diff
    character(len=MAX_CHARACTER_LEN), dimension(:), allocatable :: unittest_error_rank1_a, &
        unittest_error_rank1_b, unittest_error_rank1_extra
#endif

    type, extends(unittest_error) :: unittest_error_rank2
#ifndef FC_NO_ALLOCATABLE_DTCOMP
        logical, dimension(:,:), allocatable :: diff
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:,:), allocatable :: a,b, extra
#else
        character(:), dimension(:,:), allocatable :: a,b, extra
#endif
#endif
    contains
        procedure :: write_to => unittest_error_write_to_rank2
    end type unittest_error_rank2
#ifdef FC_NO_ALLOCATABLE_DTCOMP
    logical, dimension(:,:), allocatable :: unittest_error_rank2_diff
    character(len=MAX_CHARACTER_LEN), dimension(:,:), allocatable :: unittest_error_rank2_a, &
        unittest_error_rank2_b, unittest_error_rank2_extra
#endif


    !--------------------------------------------------------------------------
    ! Unit testing primitives
    !--------------------------------------------------------------------------
    
    public :: assert
    public :: assertion_fails
    interface assert
        module procedure assert_logical
    end interface assert
    
    
    public :: precondition
    interface precondition
        module procedure precondition_logical
    end interface precondition

    public :: postcondition
    interface postcondition
        module procedure postcondition_logical
    end interface postcondition

    public :: check
    interface check
        module procedure check_logical
    end interface check

    public :: unittest
    interface unittest
        module procedure unittest_logical
    end interface unittest

    public :: assert_eq
    interface assert_eq
        module procedure assert_eq_logical_rank0
        module procedure assert_eq_logical_rank1
        module procedure assert_eq_logical_rank2
        module procedure assert_eq_integer_rank0
        module procedure assert_eq_integer_rank1
        module procedure assert_eq_integer_rank2
        module procedure assert_eq_character_len_star_rank0
    end interface
    
    public :: assert_ne
    interface assert_ne
        module procedure assert_ne_logical_rank0
        module procedure assert_ne_logical_rank1
        module procedure assert_ne_logical_rank2
        module procedure assert_ne_integer_rank0
        module procedure assert_ne_integer_rank1
        module procedure assert_ne_integer_rank2
        module procedure assert_ne_character_len_star_rank0
    end interface
    
    public :: assert_lt
    interface assert_lt
        module procedure assert_lt_integer_rank0
        module procedure assert_lt_integer_rank1
        module procedure assert_lt_integer_rank2
        module procedure assert_lt_real_6_37_rank0
        module procedure assert_lt_real_6_37_rank1
        module procedure assert_lt_real_6_37_rank2
        module procedure assert_lt_real_15_307_rank0
        module procedure assert_lt_real_15_307_rank1
        module procedure assert_lt_real_15_307_rank2
        module procedure assert_lt_character_len_star_rank0
    end interface
    
    public :: assert_le
    interface assert_le
        module procedure assert_le_integer_rank0
        module procedure assert_le_integer_rank1
        module procedure assert_le_integer_rank2
        module procedure assert_le_real_6_37_rank0
        module procedure assert_le_real_6_37_rank1
        module procedure assert_le_real_6_37_rank2
        module procedure assert_le_real_15_307_rank0
        module procedure assert_le_real_15_307_rank1
        module procedure assert_le_real_15_307_rank2
        module procedure assert_le_character_len_star_rank0
    end interface
    
    public :: assert_gt
    interface assert_gt
        module procedure assert_gt_integer_rank0
        module procedure assert_gt_integer_rank1
        module procedure assert_gt_integer_rank2
        module procedure assert_gt_real_6_37_rank0
        module procedure assert_gt_real_6_37_rank1
        module procedure assert_gt_real_6_37_rank2
        module procedure assert_gt_real_15_307_rank0
        module procedure assert_gt_real_15_307_rank1
        module procedure assert_gt_real_15_307_rank2
        module procedure assert_gt_character_len_star_rank0
    end interface
    
    public :: assert_ge
    interface assert_ge
        module procedure assert_ge_integer_rank0
        module procedure assert_ge_integer_rank1
        module procedure assert_ge_integer_rank2
        module procedure assert_ge_real_6_37_rank0
        module procedure assert_ge_real_6_37_rank1
        module procedure assert_ge_real_6_37_rank2
        module procedure assert_ge_real_15_307_rank0
        module procedure assert_ge_real_15_307_rank1
        module procedure assert_ge_real_15_307_rank2
        module procedure assert_ge_character_len_star_rank0
    end interface
    
    public :: abserr
    interface abserr
        module procedure abserr_real_6_37_rank0
        module procedure abserr_real_6_37_rank1
        module procedure abserr_real_6_37_rank2
        module procedure abserr_real_15_307_rank0
        module procedure abserr_real_15_307_rank1
        module procedure abserr_real_15_307_rank2
    end interface
    
    public :: assert_abserr
    interface assert_abserr
        module procedure assert_abserr_real_6_37_rank0
        module procedure assert_abserr_real_6_37_rank1
        module procedure assert_abserr_real_6_37_rank2
        module procedure assert_abserr_real_15_307_rank0
        module procedure assert_abserr_real_15_307_rank1
        module procedure assert_abserr_real_15_307_rank2
    end interface
    
    public :: relerr
    interface relerr
        module procedure relerr_real_6_37_rank0
        module procedure relerr_real_6_37_rank1
        module procedure relerr_real_6_37_rank2
        module procedure relerr_real_15_307_rank0
        module procedure relerr_real_15_307_rank1
        module procedure relerr_real_15_307_rank2
    end interface
    
    public :: assert_relerr
    interface assert_relerr
        module procedure assert_relerr_real_6_37_rank0
        module procedure assert_relerr_real_6_37_rank1
        module procedure assert_relerr_real_6_37_rank2
        module procedure assert_relerr_real_15_307_rank0
        module procedure assert_relerr_real_15_307_rank1
        module procedure assert_relerr_real_15_307_rank2
    end interface
    
    public :: precondition_eq
    interface precondition_eq
        module procedure precondition_eq_logical_rank0
        module procedure precondition_eq_logical_rank1
        module procedure precondition_eq_logical_rank2
        module procedure precondition_eq_integer_rank0
        module procedure precondition_eq_integer_rank1
        module procedure precondition_eq_integer_rank2
        module procedure precondition_eq_character_len_star_rank0
    end interface
    
    public :: precondition_ne
    interface precondition_ne
        module procedure precondition_ne_logical_rank0
        module procedure precondition_ne_logical_rank1
        module procedure precondition_ne_logical_rank2
        module procedure precondition_ne_integer_rank0
        module procedure precondition_ne_integer_rank1
        module procedure precondition_ne_integer_rank2
        module procedure precondition_ne_character_len_star_rank0
    end interface
    
    public :: precondition_lt
    interface precondition_lt
        module procedure precondition_lt_integer_rank0
        module procedure precondition_lt_integer_rank1
        module procedure precondition_lt_integer_rank2
        module procedure precondition_lt_real_6_37_rank0
        module procedure precondition_lt_real_6_37_rank1
        module procedure precondition_lt_real_6_37_rank2
        module procedure precondition_lt_real_15_307_rank0
        module procedure precondition_lt_real_15_307_rank1
        module procedure precondition_lt_real_15_307_rank2
        module procedure precondition_lt_character_len_star_rank0
    end interface
    
    public :: precondition_le
    interface precondition_le
        module procedure precondition_le_integer_rank0
        module procedure precondition_le_integer_rank1
        module procedure precondition_le_integer_rank2
        module procedure precondition_le_real_6_37_rank0
        module procedure precondition_le_real_6_37_rank1
        module procedure precondition_le_real_6_37_rank2
        module procedure precondition_le_real_15_307_rank0
        module procedure precondition_le_real_15_307_rank1
        module procedure precondition_le_real_15_307_rank2
        module procedure precondition_le_character_len_star_rank0
    end interface
    
    public :: precondition_gt
    interface precondition_gt
        module procedure precondition_gt_integer_rank0
        module procedure precondition_gt_integer_rank1
        module procedure precondition_gt_integer_rank2
        module procedure precondition_gt_real_6_37_rank0
        module procedure precondition_gt_real_6_37_rank1
        module procedure precondition_gt_real_6_37_rank2
        module procedure precondition_gt_real_15_307_rank0
        module procedure precondition_gt_real_15_307_rank1
        module procedure precondition_gt_real_15_307_rank2
        module procedure precondition_gt_character_len_star_rank0
    end interface
    
    public :: precondition_ge
    interface precondition_ge
        module procedure precondition_ge_integer_rank0
        module procedure precondition_ge_integer_rank1
        module procedure precondition_ge_integer_rank2
        module procedure precondition_ge_real_6_37_rank0
        module procedure precondition_ge_real_6_37_rank1
        module procedure precondition_ge_real_6_37_rank2
        module procedure precondition_ge_real_15_307_rank0
        module procedure precondition_ge_real_15_307_rank1
        module procedure precondition_ge_real_15_307_rank2
        module procedure precondition_ge_character_len_star_rank0
    end interface
    
    public :: precondition_abserr
    interface precondition_abserr
        module procedure precondition_abserr_real_6_37_rank0
        module procedure precondition_abserr_real_6_37_rank1
        module procedure precondition_abserr_real_6_37_rank2
        module procedure precondition_abserr_real_15_307_rank0
        module procedure precondition_abserr_real_15_307_rank1
        module procedure precondition_abserr_real_15_307_rank2
    end interface
    
    public :: precondition_relerr
    interface precondition_relerr
        module procedure precondition_relerr_real_6_37_rank0
        module procedure precondition_relerr_real_6_37_rank1
        module procedure precondition_relerr_real_6_37_rank2
        module procedure precondition_relerr_real_15_307_rank0
        module procedure precondition_relerr_real_15_307_rank1
        module procedure precondition_relerr_real_15_307_rank2
    end interface
    
    public :: postcondition_eq
    interface postcondition_eq
        module procedure postcondition_eq_logical_rank0
        module procedure postcondition_eq_logical_rank1
        module procedure postcondition_eq_logical_rank2
        module procedure postcondition_eq_integer_rank0
        module procedure postcondition_eq_integer_rank1
        module procedure postcondition_eq_integer_rank2
        module procedure postcondition_eq_character_len_star_rank0
    end interface
    
    public :: postcondition_ne
    interface postcondition_ne
        module procedure postcondition_ne_logical_rank0
        module procedure postcondition_ne_logical_rank1
        module procedure postcondition_ne_logical_rank2
        module procedure postcondition_ne_integer_rank0
        module procedure postcondition_ne_integer_rank1
        module procedure postcondition_ne_integer_rank2
        module procedure postcondition_ne_character_len_star_rank0
    end interface
    
    public :: postcondition_lt
    interface postcondition_lt
        module procedure postcondition_lt_integer_rank0
        module procedure postcondition_lt_integer_rank1
        module procedure postcondition_lt_integer_rank2
        module procedure postcondition_lt_real_6_37_rank0
        module procedure postcondition_lt_real_6_37_rank1
        module procedure postcondition_lt_real_6_37_rank2
        module procedure postcondition_lt_real_15_307_rank0
        module procedure postcondition_lt_real_15_307_rank1
        module procedure postcondition_lt_real_15_307_rank2
        module procedure postcondition_lt_character_len_star_rank0
    end interface
    
    public :: postcondition_le
    interface postcondition_le
        module procedure postcondition_le_integer_rank0
        module procedure postcondition_le_integer_rank1
        module procedure postcondition_le_integer_rank2
        module procedure postcondition_le_real_6_37_rank0
        module procedure postcondition_le_real_6_37_rank1
        module procedure postcondition_le_real_6_37_rank2
        module procedure postcondition_le_real_15_307_rank0
        module procedure postcondition_le_real_15_307_rank1
        module procedure postcondition_le_real_15_307_rank2
        module procedure postcondition_le_character_len_star_rank0
    end interface
    
    public :: postcondition_gt
    interface postcondition_gt
        module procedure postcondition_gt_integer_rank0
        module procedure postcondition_gt_integer_rank1
        module procedure postcondition_gt_integer_rank2
        module procedure postcondition_gt_real_6_37_rank0
        module procedure postcondition_gt_real_6_37_rank1
        module procedure postcondition_gt_real_6_37_rank2
        module procedure postcondition_gt_real_15_307_rank0
        module procedure postcondition_gt_real_15_307_rank1
        module procedure postcondition_gt_real_15_307_rank2
        module procedure postcondition_gt_character_len_star_rank0
    end interface
    
    public :: postcondition_ge
    interface postcondition_ge
        module procedure postcondition_ge_integer_rank0
        module procedure postcondition_ge_integer_rank1
        module procedure postcondition_ge_integer_rank2
        module procedure postcondition_ge_real_6_37_rank0
        module procedure postcondition_ge_real_6_37_rank1
        module procedure postcondition_ge_real_6_37_rank2
        module procedure postcondition_ge_real_15_307_rank0
        module procedure postcondition_ge_real_15_307_rank1
        module procedure postcondition_ge_real_15_307_rank2
        module procedure postcondition_ge_character_len_star_rank0
    end interface
    
    public :: postcondition_abserr
    interface postcondition_abserr
        module procedure postcondition_abserr_real_6_37_rank0
        module procedure postcondition_abserr_real_6_37_rank1
        module procedure postcondition_abserr_real_6_37_rank2
        module procedure postcondition_abserr_real_15_307_rank0
        module procedure postcondition_abserr_real_15_307_rank1
        module procedure postcondition_abserr_real_15_307_rank2
    end interface
    
    public :: postcondition_relerr
    interface postcondition_relerr
        module procedure postcondition_relerr_real_6_37_rank0
        module procedure postcondition_relerr_real_6_37_rank1
        module procedure postcondition_relerr_real_6_37_rank2
        module procedure postcondition_relerr_real_15_307_rank0
        module procedure postcondition_relerr_real_15_307_rank1
        module procedure postcondition_relerr_real_15_307_rank2
    end interface
    
    public :: check_eq
    interface check_eq
        module procedure check_eq_logical_rank0
        module procedure check_eq_logical_rank1
        module procedure check_eq_logical_rank2
        module procedure check_eq_integer_rank0
        module procedure check_eq_integer_rank1
        module procedure check_eq_integer_rank2
        module procedure check_eq_character_len_star_rank0
    end interface
    
    public :: check_ne
    interface check_ne
        module procedure check_ne_logical_rank0
        module procedure check_ne_logical_rank1
        module procedure check_ne_logical_rank2
        module procedure check_ne_integer_rank0
        module procedure check_ne_integer_rank1
        module procedure check_ne_integer_rank2
        module procedure check_ne_character_len_star_rank0
    end interface
    
    public :: check_lt
    interface check_lt
        module procedure check_lt_integer_rank0
        module procedure check_lt_integer_rank1
        module procedure check_lt_integer_rank2
        module procedure check_lt_real_6_37_rank0
        module procedure check_lt_real_6_37_rank1
        module procedure check_lt_real_6_37_rank2
        module procedure check_lt_real_15_307_rank0
        module procedure check_lt_real_15_307_rank1
        module procedure check_lt_real_15_307_rank2
        module procedure check_lt_character_len_star_rank0
    end interface
    
    public :: check_le
    interface check_le
        module procedure check_le_integer_rank0
        module procedure check_le_integer_rank1
        module procedure check_le_integer_rank2
        module procedure check_le_real_6_37_rank0
        module procedure check_le_real_6_37_rank1
        module procedure check_le_real_6_37_rank2
        module procedure check_le_real_15_307_rank0
        module procedure check_le_real_15_307_rank1
        module procedure check_le_real_15_307_rank2
        module procedure check_le_character_len_star_rank0
    end interface
    
    public :: check_gt
    interface check_gt
        module procedure check_gt_integer_rank0
        module procedure check_gt_integer_rank1
        module procedure check_gt_integer_rank2
        module procedure check_gt_real_6_37_rank0
        module procedure check_gt_real_6_37_rank1
        module procedure check_gt_real_6_37_rank2
        module procedure check_gt_real_15_307_rank0
        module procedure check_gt_real_15_307_rank1
        module procedure check_gt_real_15_307_rank2
        module procedure check_gt_character_len_star_rank0
    end interface
    
    public :: check_ge
    interface check_ge
        module procedure check_ge_integer_rank0
        module procedure check_ge_integer_rank1
        module procedure check_ge_integer_rank2
        module procedure check_ge_real_6_37_rank0
        module procedure check_ge_real_6_37_rank1
        module procedure check_ge_real_6_37_rank2
        module procedure check_ge_real_15_307_rank0
        module procedure check_ge_real_15_307_rank1
        module procedure check_ge_real_15_307_rank2
        module procedure check_ge_character_len_star_rank0
    end interface
    
    public :: check_abserr
    interface check_abserr
        module procedure check_abserr_real_6_37_rank0
        module procedure check_abserr_real_6_37_rank1
        module procedure check_abserr_real_6_37_rank2
        module procedure check_abserr_real_15_307_rank0
        module procedure check_abserr_real_15_307_rank1
        module procedure check_abserr_real_15_307_rank2
    end interface
    
    public :: check_relerr
    interface check_relerr
        module procedure check_relerr_real_6_37_rank0
        module procedure check_relerr_real_6_37_rank1
        module procedure check_relerr_real_6_37_rank2
        module procedure check_relerr_real_15_307_rank0
        module procedure check_relerr_real_15_307_rank1
        module procedure check_relerr_real_15_307_rank2
    end interface
    
    public :: unittest_eq
    interface unittest_eq
        module procedure unittest_eq_logical_rank0
        module procedure unittest_eq_logical_rank1
        module procedure unittest_eq_logical_rank2
        module procedure unittest_eq_integer_rank0
        module procedure unittest_eq_integer_rank1
        module procedure unittest_eq_integer_rank2
        module procedure unittest_eq_character_len_star_rank0
    end interface
    
    public :: unittest_ne
    interface unittest_ne
        module procedure unittest_ne_logical_rank0
        module procedure unittest_ne_logical_rank1
        module procedure unittest_ne_logical_rank2
        module procedure unittest_ne_integer_rank0
        module procedure unittest_ne_integer_rank1
        module procedure unittest_ne_integer_rank2
        module procedure unittest_ne_character_len_star_rank0
    end interface
    
    public :: unittest_lt
    interface unittest_lt
        module procedure unittest_lt_integer_rank0
        module procedure unittest_lt_integer_rank1
        module procedure unittest_lt_integer_rank2
        module procedure unittest_lt_real_6_37_rank0
        module procedure unittest_lt_real_6_37_rank1
        module procedure unittest_lt_real_6_37_rank2
        module procedure unittest_lt_real_15_307_rank0
        module procedure unittest_lt_real_15_307_rank1
        module procedure unittest_lt_real_15_307_rank2
        module procedure unittest_lt_character_len_star_rank0
    end interface
    
    public :: unittest_le
    interface unittest_le
        module procedure unittest_le_integer_rank0
        module procedure unittest_le_integer_rank1
        module procedure unittest_le_integer_rank2
        module procedure unittest_le_real_6_37_rank0
        module procedure unittest_le_real_6_37_rank1
        module procedure unittest_le_real_6_37_rank2
        module procedure unittest_le_real_15_307_rank0
        module procedure unittest_le_real_15_307_rank1
        module procedure unittest_le_real_15_307_rank2
        module procedure unittest_le_character_len_star_rank0
    end interface
    
    public :: unittest_gt
    interface unittest_gt
        module procedure unittest_gt_integer_rank0
        module procedure unittest_gt_integer_rank1
        module procedure unittest_gt_integer_rank2
        module procedure unittest_gt_real_6_37_rank0
        module procedure unittest_gt_real_6_37_rank1
        module procedure unittest_gt_real_6_37_rank2
        module procedure unittest_gt_real_15_307_rank0
        module procedure unittest_gt_real_15_307_rank1
        module procedure unittest_gt_real_15_307_rank2
        module procedure unittest_gt_character_len_star_rank0
    end interface
    
    public :: unittest_ge
    interface unittest_ge
        module procedure unittest_ge_integer_rank0
        module procedure unittest_ge_integer_rank1
        module procedure unittest_ge_integer_rank2
        module procedure unittest_ge_real_6_37_rank0
        module procedure unittest_ge_real_6_37_rank1
        module procedure unittest_ge_real_6_37_rank2
        module procedure unittest_ge_real_15_307_rank0
        module procedure unittest_ge_real_15_307_rank1
        module procedure unittest_ge_real_15_307_rank2
        module procedure unittest_ge_character_len_star_rank0
    end interface
    
    public :: unittest_abserr
    interface unittest_abserr
        module procedure unittest_abserr_real_6_37_rank0
        module procedure unittest_abserr_real_6_37_rank1
        module procedure unittest_abserr_real_6_37_rank2
        module procedure unittest_abserr_real_15_307_rank0
        module procedure unittest_abserr_real_15_307_rank1
        module procedure unittest_abserr_real_15_307_rank2
    end interface
    
    public :: unittest_relerr
    interface unittest_relerr
        module procedure unittest_relerr_real_6_37_rank0
        module procedure unittest_relerr_real_6_37_rank1
        module procedure unittest_relerr_real_6_37_rank2
        module procedure unittest_relerr_real_15_307_rank0
        module procedure unittest_relerr_real_15_307_rank1
        module procedure unittest_relerr_real_15_307_rank2
    end interface
    
    
contains

    !--------------------------------------------------------------------------
    ! Unit testing
    !--------------------------------------------------------------------------
    
    ! Reset the test results
    subroutine unittest_reset(name)
        character(len=*),intent(in), optional :: name
        ntest = 0
        nfail = 0
        module_name = optional_character( name, "" )
    end subroutine unittest_reset
    
    ! Returns the results of the test so far.
    subroutine unittest_results(nb_passed,nb_failed,nb_tests)
        integer, intent( out ), optional :: nb_passed, nb_failed, nb_tests
        if( present( nb_passed ) ) nb_passed = ntest-nfail
        if( present( nb_failed ) ) nb_failed = nfail
        if( present( nb_tests  ) ) nb_tests  = ntest
    end subroutine unittest_results
    
    ! Write the test report in a fashion compatible to the test warnings.
    subroutine unittest_report()
        integer :: nb_failed, nb_tests
        call unittest_results(nb_failed=nb_failed, nb_tests=nb_tests)
        if( nb_failed == 0 ) then
            write(unit=*,fmt="(A)",advance="no") "    [OK] "
        else
            write(unit=*,fmt="(A)",advance="no") "    [??] "
        end if
        if( nb_failed == 0 ) then
            write(unit=*,fmt="(A,I4,A)",advance="no") &
                "All ", nb_tests, " tests passed!"
        else
            write(unit=*,fmt="(I4,A,I4,A)",advance="no") &
                nb_tests-nb_failed, " of ", nb_tests, " tests passed"
        end if
        if( len_trim(module_name) /= 0 ) &
            write(unit=*,fmt="(3A)",advance="no") " (", trim(module_name), ")"
        write(unit=*,fmt=*) ! New line
    end subroutine unittest_report

    !--------------------------------------------------------------------------
    ! Primitives
    !--------------------------------------------------------------------------
    
    subroutine handle_unittest( ifail, ifail_argument )
        type(error), intent(in out) :: ifail
        type(error), intent(out), optional :: ifail_argument
        ntest = ntest + 1
        if( is_error( ifail ) ) then
            nfail = nfail + 1
            if( present(ifail_argument) ) then
                print *, "*** Experimental: handle_unittest with ifail_argument"
                ifail_argument = ifail ! Copy
            end if
            print *, ""
            call report_error( ifail )
            print *, ""
        end if
    end subroutine handle_unittest
    
    subroutine assert_logical( expression, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, intent(in) :: expression
        
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        call assert_eq( expression, .true., &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine assert_logical
    
    subroutine precondition_logical( expression, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, intent(in) :: expression
        
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_precondition() ) return
        call assert_logical( expression, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_logical
    subroutine postcondition_logical( expression, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, intent(in) :: expression
        
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_postcondition() ) return
        call assert_logical( expression, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_logical
    subroutine check_logical( expression, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, intent(in) :: expression
        
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_check() ) return
        call assert_logical( expression, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_logical
    subroutine unittest_logical( expression, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, intent(in) :: expression
        
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_logical( expression, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_logical
    
    function assertion_fails( expression, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) result( failed )
        logical, intent(in) :: expression
        
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        logical :: failed
        
        call assert_logical( expression, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        failed = is_error( ifail )
        
    end function assertion_fails

    !--------------------------------------------------------------------------
    ! Reporting
    !--------------------------------------------------------------------------
    
    ! The first common line of each report: information about where the test failed
    subroutine report_header( info, unit, prefix, suffix, recursion )
        class(unittest_error), intent(in) :: info
        integer, intent(in) :: unit
        character(len=*), intent(in) :: prefix, suffix
        logical, intent(in), optional :: recursion
        
        ! Report this only at the outer most level
        if( optional_logical( recursion,.false. ) ) return
            
        write(unit=unit,fmt="(A)",advance="no") prefix
        
        if( len_trim(module_name) > 0 ) then
            write(unit=unit,fmt="(3A)",advance="no") "[", trim(module_name), "] "
        end if
        
        if( ntest >= 0 ) then !   20120725 KP - TODO: incorrect
            write(unit=unit,fmt="(A,I0)",advance="no") "Test ", ntest
        else
            write(unit=unit,fmt="(A)",advance="no") "Run-time check"
        end if
        
#ifndef FC_NO_ALLOCATABLE_DTCOMP
        if( allocated(info%filename) ) then
#endif
            if( len_trim(info%filename) > 0 ) then
                write(unit=unit,fmt="(2A)",advance="no") " in ", trim(info%filename)
            end if
#ifndef FC_NO_ALLOCATABLE_DTCOMP
        end if
#endif
        
        if( info%line > 0 ) then
            write(unit=unit,fmt="(A,I0)",advance="no") "@", info%line
        end if
        
#ifndef FC_NO_ALLOCATABLE_DTCOMP
        if( allocated(info%statement) ) then
#endif
            if( len_trim(info%statement) > 0 ) then
                write(unit=unit,fmt="(2A)",advance="no") ": ", trim(info%statement)
            end if
#ifndef FC_NO_ALLOCATABLE_DTCOMP
        end if
#endif
#ifndef FC_NO_ALLOCATABLE_DTCOMP
        if( allocated(info%comment) ) then
#endif
            if( len_trim(info%comment) > 0 ) then
                write(unit=unit,fmt="(3A)",advance="no") " (", trim(info%comment), ")"
            end if
#ifndef FC_NO_ALLOCATABLE_DTCOMP
        end if
#endif
            
        write(unit=unit,fmt="(A)") suffix
        
    end subroutine report_header
    
    ! For arrays: report how many elements differ
    subroutine report_header_nb_differences( unit,prefix,suffix,  nb_diff,nb, recursion )
        integer, intent(in) :: unit
        character(len=*), intent(in) :: prefix, suffix
        integer, intent(in) :: nb_diff, nb
        logical, intent(in), optional :: recursion
        
        ! Report this only at the outer most level
        if( optional_logical( recursion,.false. ) ) return
        
        if( nb_diff == nb .and. nb == 1 ) then
            ! Do not report, just two different scalars
        else if( nb_diff == nb ) then
            write(unit=unit,fmt="(2A,I0,2A)") prefix, &
                "All the ", nb, " elements differ: ", suffix
        else
            write(unit=unit,fmt="(A,I0,A,I0,2A)") prefix, &
                nb_diff, " of the ", nb, " elements differs: ", suffix
        end if
        
    end subroutine report_header_nb_differences
    
    ! Common routine for the format string of the report's output
    subroutine prepare_format_string( fmt_str, nb, name_width, element_width, leading_spaces, sep )
        character(len=*), intent(out) :: fmt_str
        integer, intent(in) :: nb, name_width, element_width
        integer, dimension(:), intent(in) :: leading_spaces
        character(len=*), intent(in) :: sep
        character(len=40) :: part
        integer :: i
        
        fmt_str = "(A"
        write(unit=part,fmt="(A,I0)") "A", name_width
        fmt_str = trim(fmt_str) // "," // trim(part)
        fmt_str = trim(fmt_str) // ",A" ! Equal sign
        write(unit=part,fmt="(A,I0,A)") "(A", element_width-leading_spaces(1), ")"
        fmt_str = trim(fmt_str) // "," // trim(part)
        do i=2,nb
            write(unit=part,fmt="(3A,I0,A)") "('", sep, "',A", element_width-leading_spaces(i), ")"
            fmt_str = trim(fmt_str) // "," // trim(part)
        end do
        fmt_str = trim(fmt_str) // ",2A)" ! trailing + suffix
        
    end subroutine prepare_format_string
    
    ! Report details about the differences between rank-1 arrays. 
    ! The optional arguments can be used to overwrite those stored in the <info> argument.
    subroutine report_details_rank1( info, unit, prefix, suffix, diff, a, b, extra, &
                    a_name, b_name,extra_name, idx_row, recursion )
        class(unittest_error), intent(in) :: info
        integer, intent(in) :: unit
        character(len=*), intent(in) :: prefix, suffix
        
        logical, dimension(:), intent(in) :: diff
        character(len=*), dimension(:), intent(in) :: a, b
        character(len=*), dimension(:), intent(in), optional :: extra
        
        character(len=*), intent(in), optional :: a_name, b_name, extra_name
        character(len=*), dimension(:), intent(in), optional :: idx_row
        logical, intent(in), optional :: recursion
        
        ! Local variables
        character(len=3), parameter :: eqs = " = ", sep = " | ", blk = "   "
        integer, dimension(:), allocatable :: diff_idx
        integer :: i,j, element_width, nb, nb_diff, max_elements_per_row, row, idx, name_width, stat, idx_width, width
        logical :: isspace
        integer, dimension(size(diff)) :: leading_spaces
        character(len=300) :: fmt_str, la_name, lb_name, trailing, lextra_name
        character(len=len(blk)) :: sep_or_blk
        character(len=len_trim(a(1))), dimension(size(a)) :: diff_str, the_row
        
        ! Get the actual names and their maximum width
        la_name     = optional_allocatable_character( a_name,     info%a_name,    "a" )
        lb_name     = optional_allocatable_character( b_name,     info%b_name,    "b" )
        lextra_name = optional_allocatable_character( extra_name, info%extra_name, "" )
        name_width = max(1,len_trim(la_name),len_trim(lb_name),len_trim(lextra_name))
        
        ! Some statistics
        element_width = max(maxval(len_trim(a)),maxval(len_trim(b)))
        nb = size(diff)
        nb_diff = count(diff)
        
        ! Common header
        call report_header( info, unit, prefix, suffix, recursion )
        call report_header_nb_differences( unit,prefix,suffix, nb_diff,nb, recursion )
        
        ! Get the indexes of the differences the PACK instruction masks 1,...,nb
        ! with the diff logical array and thus returns exactly those indexes.
        allocate(diff_idx(nb_diff),stat=stat)
        if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
            "diff_idx(", nb_diff, ")) (report_details_rank1)"
        diff_idx = pack( (/ (i,i=1,nb) /), diff )
        
        ! Remove excess leading spaces
        leading_spaces(:) = 0
        do i=1,nb
            isspace = .true.
            do j=1,len_trim(a(i))
                isspace = a(i)(j:j) == " " .and. b(i)(j:j) == " "
                if( present(extra) ) then
                    isspace = isspace .and. extra(i)(j:j) == " "
                end if
                if( isspace ) then
                    leading_spaces(i) = j
                end if
            end do
        end do
        
        ! Prepare the difference strings: put "-" where they are equal, "^" when they differ
        diff_str = " "
        do i=1,nb_diff
            idx = diff_idx(i)
            do j=1+leading_spaces(idx),len_trim(a(idx))
                if( a(idx)(j:j) /= b(idx)(j:j) ) then
                    diff_str(idx)(j:j) = "^"
                else
                    diff_str(idx)(j:j) = "-"
                end if
            end do
        end do
        
        ! How many elements can we show on one row?
!         ! Assumes equal width elements
!         max_elements_per_row = (OUTPUT_WIDTH-name_width-len(prefix)-len(suffix)-len(eqs))/ &
!             (element_width+len(sep)) ! Integer division -< floored
        max_elements_per_row = 1
        width = name_width + len(prefix) + len(suffix) + len(eqs) + (element_width-leading_spaces(1))
        do idx=2,nb
            width = width + len(sep) + (element_width-leading_spaces(idx))
            if( width <= OUTPUT_WIDTH ) then
                max_elements_per_row = idx
            else
                exit
            end if
        end do
        
        ! Case 1: report all the differences, without compressing the results
        if( optional_logical( recursion,.false.) .or. (nb <= max_elements_per_row .and. .not. present(idx_row)) ) then
            ! Possibly, not all elements fit and the output is truncated
            if( nb > max_elements_per_row ) then
                nb = max_elements_per_row
                write(unit=trailing,fmt="(2A)") sep, "..."
            else
                trailing = ""
            end if
            
            ! Prepare format string and output the values of a and b
            call prepare_format_string( fmt_str, nb, name_width, element_width, leading_spaces, sep )
            write(unit=unit,fmt=fmt_str) prefix, trim(la_name), eqs, adjustl(a(1:nb)), trim(trailing), suffix
            write(unit=unit,fmt=fmt_str) prefix, trim(lb_name), eqs, adjustl(b(1:nb)), trim(trailing), suffix
            
            ! Idemdito for the differences, but now without sep
            if( info%show_difference_marks ) then
                call prepare_format_string( fmt_str, nb, name_width, element_width, leading_spaces, blk )
                write(unit=unit,fmt=fmt_str) prefix, "", blk, adjustl(diff_str(1:nb)), trim(trailing), suffix
            end if
            
            ! If needed, also do this for extra
            if( present(extra) ) then
                call prepare_format_string( fmt_str, nb, name_width, element_width, leading_spaces, sep )
                write(unit=unit,fmt=fmt_str) prefix, trim(lextra_name), eqs, adjustl(extra(1:nb)), trim(trailing), suffix
            end if
            return
        end if
        
        ! Case 2: report the differences selectively, by only showing the columns that differ
        name_width = max(name_width,3) ! Ensure at least idx can be shown as name
        do row=0,4
            if( .not. present(extra) .and. row == 4 ) then
                exit ! No extra -> stop the loop here
            end if
            if( row /= 3 .or. info%show_difference_marks ) then
                write(unit=unit,fmt="(A)",advance="no") prefix
                
                ! Write the name and assign the contents of the current row to <the_row>
                write(unit=fmt_str,fmt="(2(A,I0),A)") "(A",name_width,",A",len(eqs),")"
                select case( row )
                    case( 0 ) ! Indexes
                        if( name_width < 5 ) then
                            write(unit=unit,fmt=fmt_str,advance="no") "idx", eqs
                        else
                            write(unit=unit,fmt=fmt_str,advance="no") "index", eqs
                        end if
                    
                        if( present( idx_row ) ) then
                            the_row = idx_row
                        else
                            the_row = " "
                            write(unit=fmt_str,fmt="(A,I0,A)") "(I", element_width, ")"
                            do i=1,nb_diff
                                idx = diff_idx(i)
                                write(unit=the_row(idx),fmt=fmt_str) idx
                                
                                ! Adapt leading_spaces so it shows the full index
                                idx_width = len_trim(adjustl(the_row(idx)))
                                if( idx_width > element_width-leading_spaces(idx) ) then
                                    leading_spaces(idx) = element_width-idx_width
                                end if
                            end do
                        end if
                    case( 1 ) ! a
                        write(unit=unit,fmt=fmt_str,advance="no") trim(la_name), eqs
                        the_row = a
                    case( 2 ) ! b
                        write(unit=unit,fmt=fmt_str,advance="no") trim(lb_name), eqs
                        the_row = b
                    case( 3 ) ! differences
                        write(unit=unit,fmt=fmt_str,advance="no") "",""
                        the_row = diff_str
                    case( 4 ) ! extra
                        write(unit=unit,fmt=fmt_str,advance="no") lextra_name, eqs
                        the_row = extra
                end select
                
                ! The seperator in between the columns
                if( row == 3 ) then
                    sep_or_blk = blk
                else
                    sep_or_blk = sep
                end if
                
                ! Report the rows
                idx = 0
                do i=1,min(nb_diff,max_elements_per_row)
                    if( i>1 ) then
                        write(unit=unit,fmt="(A)",advance="no") sep_or_blk
                    end if
                    
                    ! Were there elements in between?
                    if( diff_idx(i) > idx+1 ) then
                        write(unit=unit,fmt="(2A)",advance="no") ".", sep_or_blk
                    end if
                    
                    ! Element
                    idx = diff_idx(i)
                    write(unit=unit,fmt="(A)",advance="no") the_row(idx)(1+leading_spaces(idx):element_width)
                end do
                if( nb_diff > max_elements_per_row ) then
                    write(unit=unit,fmt="(2A)",advance="no") sep_or_blk, "..."
                else if( diff_idx(min(nb_diff,max_elements_per_row)) < len(eqs) ) then
                    write(unit=unit,fmt="(2A)",advance="no") sep_or_blk, "."
                end if
                
                write(unit=unit,fmt="(A)",advance="yes") suffix
            end if
        end do
        
    end subroutine report_details_rank1
    
    ! Analogue of report_details_rank1, but for rank-2 arrays
    subroutine report_details_rank2( info, unit, prefix, suffix, diff, a,b,extra, &
                    a_name,b_name,extra_name, recursion )
        class(unittest_error), intent(in) :: info
        integer, intent(in) :: unit
        character(len=*), intent(in) :: prefix, suffix
        logical, dimension(:,:), intent(in) :: diff
        character(len=*), dimension(:,:), intent(in) :: a,b
        
        character(len=*), dimension(:,:), intent(in), optional :: extra
        character(len=*), intent(in), optional :: a_name, b_name, extra_name
        logical, intent(in), optional :: recursion
        
        ! Local variables
        character(len=40) :: a_rowstr, b_rowstr, fmt_str
        integer :: row, prev_row
        
        ! Common header
        call report_header( info, unit, prefix, suffix, recursion )
        call report_header_nb_differences( unit,prefix,suffix, count(diff),size(diff), recursion ) 
        
        ! Boolean overview of the array and its differences
        do row=1,size(a,1)
            write(unit=unit,fmt="(A,100L2)",advance="no") prefix, .not. diff(row,:) ! Assuming less than 100 elements ...
            write(unit=unit,fmt="(A)") suffix
        end do
        
        ! Prepare the format string for the indexing of the rows of a and b
        write(unit=fmt_str,fmt="(A,I0,A)") "(2A,I",ceiling(log10(real(size(a,1)))),",A)"
        
        ! Iterate over all rows, keeping track of the previous row to indicate supressed rows
        prev_row = 0
        do row=1,size(a,1)
            ! Only report rows with differences
            if( any(diff(row,:)) ) then
                ! Indicate that equal rows were supressed
                if( row /= prev_row+1 ) then
                    write(unit=unit,fmt="(3A)") prefix, "(equal rows suppressed)", suffix
                end if
                
                ! Name overwrites for the indexed rows
                write(unit=a_rowstr,fmt=fmt_str) trim(optional_allocatable_character(a_name, info%a_name, "a" )), "(", row, ",:)"
                write(unit=b_rowstr,fmt=fmt_str) trim(optional_allocatable_character(b_name, info%b_name, "b" )), "(", row, ",:)"
                
                if( present(extra) ) then
                    call report_details_rank1( info,unit,prefix,suffix, diff(row,:),a(row,:),b(row,:),extra(row,:), &
                                a_name=a_rowstr,b_name=b_rowstr, recursion=.true., &
                                extra_name=optional_allocatable_character( extra_name, info%extra_name, "extra" ) )
                    ! Extra separating line to avoid confusion in case there was extra information
                    if( row < size(a,1) ) then
                        write(unit=unit,fmt="(3A)") prefix, repeat("-",len_trim(a_rowstr)), suffix
                    end if
                else
                    call report_details_rank1( info,unit,prefix,suffix, diff(row,:),a(row,:),b(row,:), &
                                a_name=a_rowstr,b_name=b_rowstr, recursion=.true. )
                end if
                prev_row = row
            end if
        end do
        if( size(a,1) /= prev_row ) then
            write(unit=unit,fmt="(3A)") prefix, "(equal rows suppressed)", suffix
        end if
        
    end subroutine report_details_rank2

    !--------------------------------------------------------------------------
    ! Type bound procedures
    !--------------------------------------------------------------------------
    ! TODO: better way of handling the optionally allocated info%extra?
    
    subroutine unittest_error_write_to_rank0( info, unit, prefix, suffix )
        class(unittest_error_rank0), intent(in) :: info
        integer, intent(in) :: unit
        character(len=*), intent(in) :: prefix, suffix
        
#ifndef FC_NO_ALLOCATABLE_DTCOMP
        associate( diff=>info%diff )
            if( allocated(info%extra) ) then
                call report_details_rank1( info, unit, prefix, suffix, &
                        (/ diff /), (/ info%a /), (/ info%b /), (/ info%extra /) )
            else
                call report_details_rank1( info, unit, prefix, suffix, &
                        (/ diff /), (/ info%a /), (/ info%b /) )
            end if
        end associate
#else
        associate( diff=>unittest_error_rank0_diff, &
                    a=>unittest_error_rank0_a, b=>unittest_error_rank0_b )
            if( len_trim(unittest_error_rank0_extra) > 0 ) then
                call report_details_rank1( info, unit, prefix, suffix, &
                        (/ diff /), (/ a /), (/ b /), (/ unittest_error_rank0_extra /) )
                return
            end if
            call report_details_rank1( info, unit, prefix, suffix, &
                    (/ diff /), (/ a /), (/ b /) )
        end associate
#endif
        
    end subroutine unittest_error_write_to_rank0
    
    subroutine unittest_error_write_to_rank1( info, unit, prefix, suffix )
        class(unittest_error_rank1), intent(in) :: info
        integer, intent(in) :: unit
        character(len=*), intent(in) :: prefix, suffix

#ifndef FC_NO_ALLOCATABLE_DTCOMP
        associate( diff=>info%diff )
            if( allocated(info%extra) ) then
                call report_details_rank1( info, unit, prefix, suffix, &
                    diff, info%a, info%b, info%extra )
            else
                call report_details_rank1( info, unit, prefix, suffix, &
                    diff, info%a, info%b )
            end if
        end associate
#else
        associate( diff=>unittest_error_rank1_diff, &
                    a=>unittest_error_rank1_a, b=>unittest_error_rank1_b )
            if( allocated(unittest_error_rank1_extra) ) then
                if( any(len_trim(unittest_error_rank1_extra) > 0) ) then
                    call report_details_rank1( info, unit, prefix, suffix, &
                        diff, a, b, unittest_error_rank1_extra )
                    return
                end if
            end if
            call report_details_rank1( info, unit, prefix, suffix, &
                    diff, a, b )
        end associate
#endif
    end subroutine unittest_error_write_to_rank1
    
    subroutine unittest_error_write_to_rank2( info, unit, prefix, suffix )
        class(unittest_error_rank2), intent(in) :: info
        integer, intent(in) :: unit
        character(len=*), intent(in) :: prefix, suffix
#ifndef FC_NO_ALLOCATABLE_DTCOMP
        associate( diff=>info%diff )
            if( allocated(info%extra) ) then
                call report_details_rank2( info, unit, prefix, suffix, &
                        diff, info%a, info%b, info%extra )
            else
                call report_details_rank2( info, unit, prefix, suffix, &
                        diff, info%a, info%b )
            end if
        end associate
#else
        associate( diff=>unittest_error_rank2_diff, &
                    a=>unittest_error_rank2_a, b=>unittest_error_rank2_b )
            if( allocated(unittest_error_rank2_extra) ) then
                if( any(len_trim(unittest_error_rank2_extra) > 0) ) then
                    call report_details_rank2( info, unit, prefix, suffix, &
                            diff, a, b, unittest_error_rank2_extra )
                    return
                end if
            end if
            call report_details_rank2( info, unit, prefix, suffix, &
                    diff, a, b )
        end associate
#endif       
            
        
    end subroutine unittest_error_write_to_rank2

    !--------------------------------------------------------------------------
    ! Procedure assert_eq
    !--------------------------------------------------------------------------
    
    recursive subroutine assert_eq_logical_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str
#else
        character(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        type(unittest_error_rank0) :: info
        
        if( a .eqv. b ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"L1"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_eq_logical_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_eq_logical_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a .eqv. b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( a .eqv. b )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " .eqv. " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_eq_logical_rank0
    subroutine precondition_eq_logical_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_eq_logical_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_eq_logical_rank0
    subroutine postcondition_eq_logical_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_eq_logical_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_eq_logical_rank0
    subroutine check_eq_logical_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_eq_logical_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_eq_logical_rank0
    subroutine unittest_eq_logical_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_eq_logical_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_eq_logical_rank0
    recursive subroutine assert_eq_logical_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:), allocatable :: a_str, b_str
#else
        character(:), dimension(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1
        type(unittest_error_rank1) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a .eqv. b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"L1"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1)),stat=stat)
#else
            allocate(a_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_eq_logical_rank1)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1)),stat=stat)
#else
            allocate(b_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_eq_logical_rank1)"
            
            do i1=1,size(a,1)
                write(unit=a_str(i1),fmt=lfmt) a(i1)
                write(unit=b_str(i1),fmt=lfmt) b(i1)
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a .eqv. b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank1_diff = .not. ( a .eqv. b )
            unittest_error_rank1_a = a_str
            unittest_error_rank1_b = b_str
            
            if( allocated(unittest_error_rank1_extra) ) &
                deallocate(unittest_error_rank1_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " .eqv. " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_eq_logical_rank1
    subroutine precondition_eq_logical_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_eq_logical_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_eq_logical_rank1
    subroutine postcondition_eq_logical_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_eq_logical_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_eq_logical_rank1
    subroutine check_eq_logical_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_eq_logical_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_eq_logical_rank1
    subroutine unittest_eq_logical_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_eq_logical_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_eq_logical_rank1
    recursive subroutine assert_eq_logical_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:,:), allocatable :: a_str, b_str
#else
        character(:), dimension(:,:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1,i2
        type(unittest_error_rank2) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a .eqv. b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"L1"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(a_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_eq_logical_rank2)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(b_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_eq_logical_rank2)"
            
            do i1=1,size(a,1)
            do i2=1,size(a,2)
                write(unit=a_str(i1,i2),fmt=lfmt) a(i1,i2)
                write(unit=b_str(i1,i2),fmt=lfmt) b(i1,i2)
            end do
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a .eqv. b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank2_diff = .not. ( a .eqv. b )
            unittest_error_rank2_a = a_str
            unittest_error_rank2_b = b_str
            
            if( allocated(unittest_error_rank2_extra) ) &
                deallocate(unittest_error_rank2_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " .eqv. " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_eq_logical_rank2
    subroutine precondition_eq_logical_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_eq_logical_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_eq_logical_rank2
    subroutine postcondition_eq_logical_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_eq_logical_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_eq_logical_rank2
    subroutine check_eq_logical_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_eq_logical_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_eq_logical_rank2
    subroutine unittest_eq_logical_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_eq_logical_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_eq_logical_rank2
    recursive subroutine assert_eq_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str
#else
        character(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        type(unittest_error_rank0) :: info
        
        if( a == b ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"I10"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_eq_integer_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_eq_integer_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a == b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( a == b )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " == " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_eq_integer_rank0
    subroutine precondition_eq_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_eq_integer_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_eq_integer_rank0
    subroutine postcondition_eq_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_eq_integer_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_eq_integer_rank0
    subroutine check_eq_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_eq_integer_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_eq_integer_rank0
    subroutine unittest_eq_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_eq_integer_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_eq_integer_rank0
    recursive subroutine assert_eq_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:), allocatable :: a_str, b_str
#else
        character(:), dimension(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1
        type(unittest_error_rank1) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a == b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"I10"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1)),stat=stat)
#else
            allocate(a_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_eq_integer_rank1)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1)),stat=stat)
#else
            allocate(b_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_eq_integer_rank1)"
            
            do i1=1,size(a,1)
                write(unit=a_str(i1),fmt=lfmt) a(i1)
                write(unit=b_str(i1),fmt=lfmt) b(i1)
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a == b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank1_diff = .not. ( a == b )
            unittest_error_rank1_a = a_str
            unittest_error_rank1_b = b_str
            
            if( allocated(unittest_error_rank1_extra) ) &
                deallocate(unittest_error_rank1_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " == " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_eq_integer_rank1
    subroutine precondition_eq_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_eq_integer_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_eq_integer_rank1
    subroutine postcondition_eq_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_eq_integer_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_eq_integer_rank1
    subroutine check_eq_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_eq_integer_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_eq_integer_rank1
    subroutine unittest_eq_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_eq_integer_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_eq_integer_rank1
    recursive subroutine assert_eq_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:,:), allocatable :: a_str, b_str
#else
        character(:), dimension(:,:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1,i2
        type(unittest_error_rank2) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a == b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"I10"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(a_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_eq_integer_rank2)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(b_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_eq_integer_rank2)"
            
            do i1=1,size(a,1)
            do i2=1,size(a,2)
                write(unit=a_str(i1,i2),fmt=lfmt) a(i1,i2)
                write(unit=b_str(i1,i2),fmt=lfmt) b(i1,i2)
            end do
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a == b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank2_diff = .not. ( a == b )
            unittest_error_rank2_a = a_str
            unittest_error_rank2_b = b_str
            
            if( allocated(unittest_error_rank2_extra) ) &
                deallocate(unittest_error_rank2_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " == " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_eq_integer_rank2
    subroutine precondition_eq_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_eq_integer_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_eq_integer_rank2
    subroutine postcondition_eq_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_eq_integer_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_eq_integer_rank2
    subroutine check_eq_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_eq_integer_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_eq_integer_rank2
    subroutine unittest_eq_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_eq_integer_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_eq_integer_rank2
    recursive subroutine assert_eq_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str
#else
        character(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        type(unittest_error_rank0) :: info
        
        if( a == b ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"A20"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_eq_character_len_star_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_eq_character_len_star_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            ! Left-align character strings
            a_str = adjustl( a_str )
            b_str = adjustl( b_str )
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a == b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( a == b )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " == " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_eq_character_len_star_rank0
    subroutine precondition_eq_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_eq_character_len_star_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_eq_character_len_star_rank0
    subroutine postcondition_eq_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_eq_character_len_star_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_eq_character_len_star_rank0
    subroutine check_eq_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_eq_character_len_star_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_eq_character_len_star_rank0
    subroutine unittest_eq_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_eq_character_len_star_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_eq_character_len_star_rank0

    !--------------------------------------------------------------------------
    ! Procedure assert_ne
    !--------------------------------------------------------------------------
    
    recursive subroutine assert_ne_logical_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str
#else
        character(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        type(unittest_error_rank0) :: info
        
        if( a .neqv. b ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"L1"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_ne_logical_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_ne_logical_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a .neqv. b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( a .neqv. b )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " .neqv. " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_ne_logical_rank0
    subroutine precondition_ne_logical_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_ne_logical_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_ne_logical_rank0
    subroutine postcondition_ne_logical_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_ne_logical_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_ne_logical_rank0
    subroutine check_ne_logical_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_ne_logical_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_ne_logical_rank0
    subroutine unittest_ne_logical_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_ne_logical_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_ne_logical_rank0
    recursive subroutine assert_ne_logical_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:), allocatable :: a_str, b_str
#else
        character(:), dimension(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1
        type(unittest_error_rank1) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a .neqv. b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"L1"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1)),stat=stat)
#else
            allocate(a_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_ne_logical_rank1)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1)),stat=stat)
#else
            allocate(b_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_ne_logical_rank1)"
            
            do i1=1,size(a,1)
                write(unit=a_str(i1),fmt=lfmt) a(i1)
                write(unit=b_str(i1),fmt=lfmt) b(i1)
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a .neqv. b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank1_diff = .not. ( a .neqv. b )
            unittest_error_rank1_a = a_str
            unittest_error_rank1_b = b_str
            
            if( allocated(unittest_error_rank1_extra) ) &
                deallocate(unittest_error_rank1_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " .neqv. " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_ne_logical_rank1
    subroutine precondition_ne_logical_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_ne_logical_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_ne_logical_rank1
    subroutine postcondition_ne_logical_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_ne_logical_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_ne_logical_rank1
    subroutine check_ne_logical_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_ne_logical_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_ne_logical_rank1
    subroutine unittest_ne_logical_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_ne_logical_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_ne_logical_rank1
    recursive subroutine assert_ne_logical_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:,:), allocatable :: a_str, b_str
#else
        character(:), dimension(:,:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1,i2
        type(unittest_error_rank2) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a .neqv. b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"L1"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(a_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_ne_logical_rank2)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(b_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_ne_logical_rank2)"
            
            do i1=1,size(a,1)
            do i2=1,size(a,2)
                write(unit=a_str(i1,i2),fmt=lfmt) a(i1,i2)
                write(unit=b_str(i1,i2),fmt=lfmt) b(i1,i2)
            end do
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a .neqv. b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank2_diff = .not. ( a .neqv. b )
            unittest_error_rank2_a = a_str
            unittest_error_rank2_b = b_str
            
            if( allocated(unittest_error_rank2_extra) ) &
                deallocate(unittest_error_rank2_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " .neqv. " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_ne_logical_rank2
    subroutine precondition_ne_logical_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_ne_logical_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_ne_logical_rank2
    subroutine postcondition_ne_logical_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_ne_logical_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_ne_logical_rank2
    subroutine check_ne_logical_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_ne_logical_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_ne_logical_rank2
    subroutine unittest_ne_logical_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        logical, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_ne_logical_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_ne_logical_rank2
    recursive subroutine assert_ne_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str
#else
        character(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        type(unittest_error_rank0) :: info
        
        if( a /= b ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"I10"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_ne_integer_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_ne_integer_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a /= b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( a /= b )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " /= " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_ne_integer_rank0
    subroutine precondition_ne_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_ne_integer_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_ne_integer_rank0
    subroutine postcondition_ne_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_ne_integer_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_ne_integer_rank0
    subroutine check_ne_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_ne_integer_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_ne_integer_rank0
    subroutine unittest_ne_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_ne_integer_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_ne_integer_rank0
    recursive subroutine assert_ne_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:), allocatable :: a_str, b_str
#else
        character(:), dimension(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1
        type(unittest_error_rank1) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a /= b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"I10"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1)),stat=stat)
#else
            allocate(a_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_ne_integer_rank1)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1)),stat=stat)
#else
            allocate(b_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_ne_integer_rank1)"
            
            do i1=1,size(a,1)
                write(unit=a_str(i1),fmt=lfmt) a(i1)
                write(unit=b_str(i1),fmt=lfmt) b(i1)
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a /= b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank1_diff = .not. ( a /= b )
            unittest_error_rank1_a = a_str
            unittest_error_rank1_b = b_str
            
            if( allocated(unittest_error_rank1_extra) ) &
                deallocate(unittest_error_rank1_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " /= " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_ne_integer_rank1
    subroutine precondition_ne_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_ne_integer_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_ne_integer_rank1
    subroutine postcondition_ne_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_ne_integer_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_ne_integer_rank1
    subroutine check_ne_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_ne_integer_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_ne_integer_rank1
    subroutine unittest_ne_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_ne_integer_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_ne_integer_rank1
    recursive subroutine assert_ne_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:,:), allocatable :: a_str, b_str
#else
        character(:), dimension(:,:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1,i2
        type(unittest_error_rank2) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a /= b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"I10"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(a_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_ne_integer_rank2)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(b_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_ne_integer_rank2)"
            
            do i1=1,size(a,1)
            do i2=1,size(a,2)
                write(unit=a_str(i1,i2),fmt=lfmt) a(i1,i2)
                write(unit=b_str(i1,i2),fmt=lfmt) b(i1,i2)
            end do
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a /= b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank2_diff = .not. ( a /= b )
            unittest_error_rank2_a = a_str
            unittest_error_rank2_b = b_str
            
            if( allocated(unittest_error_rank2_extra) ) &
                deallocate(unittest_error_rank2_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " /= " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_ne_integer_rank2
    subroutine precondition_ne_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_ne_integer_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_ne_integer_rank2
    subroutine postcondition_ne_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_ne_integer_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_ne_integer_rank2
    subroutine check_ne_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_ne_integer_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_ne_integer_rank2
    subroutine unittest_ne_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_ne_integer_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_ne_integer_rank2
    recursive subroutine assert_ne_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str
#else
        character(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        type(unittest_error_rank0) :: info
        
        if( a /= b ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"A20"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_ne_character_len_star_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_ne_character_len_star_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            ! Left-align character strings
            a_str = adjustl( a_str )
            b_str = adjustl( b_str )
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a /= b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( a /= b )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " /= " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_ne_character_len_star_rank0
    subroutine precondition_ne_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_ne_character_len_star_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_ne_character_len_star_rank0
    subroutine postcondition_ne_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_ne_character_len_star_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_ne_character_len_star_rank0
    subroutine check_ne_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_ne_character_len_star_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_ne_character_len_star_rank0
    subroutine unittest_ne_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_ne_character_len_star_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_ne_character_len_star_rank0

    !--------------------------------------------------------------------------
    ! Procedure assert_lt
    !--------------------------------------------------------------------------
    
    recursive subroutine assert_lt_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str
#else
        character(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        type(unittest_error_rank0) :: info
        
        if( a < b ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"I10"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_lt_integer_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_lt_integer_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a < b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( a < b )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " < " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_lt_integer_rank0
    subroutine precondition_lt_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_lt_integer_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_lt_integer_rank0
    subroutine postcondition_lt_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_lt_integer_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_lt_integer_rank0
    subroutine check_lt_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_lt_integer_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_lt_integer_rank0
    subroutine unittest_lt_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_lt_integer_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_lt_integer_rank0
    recursive subroutine assert_lt_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:), allocatable :: a_str, b_str
#else
        character(:), dimension(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1
        type(unittest_error_rank1) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a < b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"I10"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1)),stat=stat)
#else
            allocate(a_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_lt_integer_rank1)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1)),stat=stat)
#else
            allocate(b_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_lt_integer_rank1)"
            
            do i1=1,size(a,1)
                write(unit=a_str(i1),fmt=lfmt) a(i1)
                write(unit=b_str(i1),fmt=lfmt) b(i1)
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a < b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank1_diff = .not. ( a < b )
            unittest_error_rank1_a = a_str
            unittest_error_rank1_b = b_str
            
            if( allocated(unittest_error_rank1_extra) ) &
                deallocate(unittest_error_rank1_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " < " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_lt_integer_rank1
    subroutine precondition_lt_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_lt_integer_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_lt_integer_rank1
    subroutine postcondition_lt_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_lt_integer_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_lt_integer_rank1
    subroutine check_lt_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_lt_integer_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_lt_integer_rank1
    subroutine unittest_lt_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_lt_integer_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_lt_integer_rank1
    recursive subroutine assert_lt_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:,:), allocatable :: a_str, b_str
#else
        character(:), dimension(:,:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1,i2
        type(unittest_error_rank2) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a < b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"I10"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(a_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_lt_integer_rank2)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(b_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_lt_integer_rank2)"
            
            do i1=1,size(a,1)
            do i2=1,size(a,2)
                write(unit=a_str(i1,i2),fmt=lfmt) a(i1,i2)
                write(unit=b_str(i1,i2),fmt=lfmt) b(i1,i2)
            end do
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a < b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank2_diff = .not. ( a < b )
            unittest_error_rank2_a = a_str
            unittest_error_rank2_b = b_str
            
            if( allocated(unittest_error_rank2_extra) ) &
                deallocate(unittest_error_rank2_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " < " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_lt_integer_rank2
    subroutine precondition_lt_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_lt_integer_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_lt_integer_rank2
    subroutine postcondition_lt_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_lt_integer_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_lt_integer_rank2
    subroutine check_lt_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_lt_integer_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_lt_integer_rank2
    subroutine unittest_lt_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_lt_integer_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_lt_integer_rank2
    recursive subroutine assert_lt_real_6_37_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str
#else
        character(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        type(unittest_error_rank0) :: info
        
        if( a < b ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES13.6"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_lt_real_6_37_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_lt_real_6_37_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a < b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( a < b )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " < " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_lt_real_6_37_rank0
    subroutine precondition_lt_real_6_37_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_lt_real_6_37_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_lt_real_6_37_rank0
    subroutine postcondition_lt_real_6_37_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_lt_real_6_37_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_lt_real_6_37_rank0
    subroutine check_lt_real_6_37_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_lt_real_6_37_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_lt_real_6_37_rank0
    subroutine unittest_lt_real_6_37_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_lt_real_6_37_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_lt_real_6_37_rank0
    recursive subroutine assert_lt_real_6_37_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:), allocatable :: a_str, b_str
#else
        character(:), dimension(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1
        type(unittest_error_rank1) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a < b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES13.6"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1)),stat=stat)
#else
            allocate(a_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_lt_real_6_37_rank1)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1)),stat=stat)
#else
            allocate(b_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_lt_real_6_37_rank1)"
            
            do i1=1,size(a,1)
                write(unit=a_str(i1),fmt=lfmt) a(i1)
                write(unit=b_str(i1),fmt=lfmt) b(i1)
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a < b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank1_diff = .not. ( a < b )
            unittest_error_rank1_a = a_str
            unittest_error_rank1_b = b_str
            
            if( allocated(unittest_error_rank1_extra) ) &
                deallocate(unittest_error_rank1_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " < " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_lt_real_6_37_rank1
    subroutine precondition_lt_real_6_37_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_lt_real_6_37_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_lt_real_6_37_rank1
    subroutine postcondition_lt_real_6_37_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_lt_real_6_37_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_lt_real_6_37_rank1
    subroutine check_lt_real_6_37_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_lt_real_6_37_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_lt_real_6_37_rank1
    subroutine unittest_lt_real_6_37_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_lt_real_6_37_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_lt_real_6_37_rank1
    recursive subroutine assert_lt_real_6_37_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:,:), allocatable :: a_str, b_str
#else
        character(:), dimension(:,:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1,i2
        type(unittest_error_rank2) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a < b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES13.6"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(a_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_lt_real_6_37_rank2)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(b_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_lt_real_6_37_rank2)"
            
            do i1=1,size(a,1)
            do i2=1,size(a,2)
                write(unit=a_str(i1,i2),fmt=lfmt) a(i1,i2)
                write(unit=b_str(i1,i2),fmt=lfmt) b(i1,i2)
            end do
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a < b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank2_diff = .not. ( a < b )
            unittest_error_rank2_a = a_str
            unittest_error_rank2_b = b_str
            
            if( allocated(unittest_error_rank2_extra) ) &
                deallocate(unittest_error_rank2_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " < " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_lt_real_6_37_rank2
    subroutine precondition_lt_real_6_37_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_lt_real_6_37_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_lt_real_6_37_rank2
    subroutine postcondition_lt_real_6_37_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_lt_real_6_37_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_lt_real_6_37_rank2
    subroutine check_lt_real_6_37_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_lt_real_6_37_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_lt_real_6_37_rank2
    subroutine unittest_lt_real_6_37_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_lt_real_6_37_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_lt_real_6_37_rank2
    recursive subroutine assert_lt_real_15_307_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str
#else
        character(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        type(unittest_error_rank0) :: info
        
        if( a < b ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES22.15"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_lt_real_15_307_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_lt_real_15_307_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a < b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( a < b )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " < " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_lt_real_15_307_rank0
    subroutine precondition_lt_real_15_307_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_lt_real_15_307_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_lt_real_15_307_rank0
    subroutine postcondition_lt_real_15_307_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_lt_real_15_307_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_lt_real_15_307_rank0
    subroutine check_lt_real_15_307_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_lt_real_15_307_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_lt_real_15_307_rank0
    subroutine unittest_lt_real_15_307_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_lt_real_15_307_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_lt_real_15_307_rank0
    recursive subroutine assert_lt_real_15_307_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:), allocatable :: a_str, b_str
#else
        character(:), dimension(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1
        type(unittest_error_rank1) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a < b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES22.15"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1)),stat=stat)
#else
            allocate(a_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_lt_real_15_307_rank1)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1)),stat=stat)
#else
            allocate(b_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_lt_real_15_307_rank1)"
            
            do i1=1,size(a,1)
                write(unit=a_str(i1),fmt=lfmt) a(i1)
                write(unit=b_str(i1),fmt=lfmt) b(i1)
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a < b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank1_diff = .not. ( a < b )
            unittest_error_rank1_a = a_str
            unittest_error_rank1_b = b_str
            
            if( allocated(unittest_error_rank1_extra) ) &
                deallocate(unittest_error_rank1_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " < " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_lt_real_15_307_rank1
    subroutine precondition_lt_real_15_307_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_lt_real_15_307_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_lt_real_15_307_rank1
    subroutine postcondition_lt_real_15_307_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_lt_real_15_307_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_lt_real_15_307_rank1
    subroutine check_lt_real_15_307_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_lt_real_15_307_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_lt_real_15_307_rank1
    subroutine unittest_lt_real_15_307_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_lt_real_15_307_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_lt_real_15_307_rank1
    recursive subroutine assert_lt_real_15_307_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:,:), allocatable :: a_str, b_str
#else
        character(:), dimension(:,:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1,i2
        type(unittest_error_rank2) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a < b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES22.15"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(a_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_lt_real_15_307_rank2)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(b_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_lt_real_15_307_rank2)"
            
            do i1=1,size(a,1)
            do i2=1,size(a,2)
                write(unit=a_str(i1,i2),fmt=lfmt) a(i1,i2)
                write(unit=b_str(i1,i2),fmt=lfmt) b(i1,i2)
            end do
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a < b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank2_diff = .not. ( a < b )
            unittest_error_rank2_a = a_str
            unittest_error_rank2_b = b_str
            
            if( allocated(unittest_error_rank2_extra) ) &
                deallocate(unittest_error_rank2_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " < " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_lt_real_15_307_rank2
    subroutine precondition_lt_real_15_307_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_lt_real_15_307_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_lt_real_15_307_rank2
    subroutine postcondition_lt_real_15_307_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_lt_real_15_307_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_lt_real_15_307_rank2
    subroutine check_lt_real_15_307_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_lt_real_15_307_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_lt_real_15_307_rank2
    subroutine unittest_lt_real_15_307_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_lt_real_15_307_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_lt_real_15_307_rank2
    recursive subroutine assert_lt_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str
#else
        character(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        type(unittest_error_rank0) :: info
        
        if( a < b ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"A20"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_lt_character_len_star_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_lt_character_len_star_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            ! Left-align character strings
            a_str = adjustl( a_str )
            b_str = adjustl( b_str )
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a < b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( a < b )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " < " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_lt_character_len_star_rank0
    subroutine precondition_lt_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_lt_character_len_star_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_lt_character_len_star_rank0
    subroutine postcondition_lt_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_lt_character_len_star_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_lt_character_len_star_rank0
    subroutine check_lt_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_lt_character_len_star_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_lt_character_len_star_rank0
    subroutine unittest_lt_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_lt_character_len_star_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_lt_character_len_star_rank0

    !--------------------------------------------------------------------------
    ! Procedure assert_le
    !--------------------------------------------------------------------------
    
    recursive subroutine assert_le_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str
#else
        character(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        type(unittest_error_rank0) :: info
        
        if( a <= b ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"I10"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_le_integer_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_le_integer_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a <= b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( a <= b )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " <= " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_le_integer_rank0
    subroutine precondition_le_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_le_integer_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_le_integer_rank0
    subroutine postcondition_le_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_le_integer_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_le_integer_rank0
    subroutine check_le_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_le_integer_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_le_integer_rank0
    subroutine unittest_le_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_le_integer_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_le_integer_rank0
    recursive subroutine assert_le_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:), allocatable :: a_str, b_str
#else
        character(:), dimension(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1
        type(unittest_error_rank1) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a <= b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"I10"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1)),stat=stat)
#else
            allocate(a_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_le_integer_rank1)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1)),stat=stat)
#else
            allocate(b_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_le_integer_rank1)"
            
            do i1=1,size(a,1)
                write(unit=a_str(i1),fmt=lfmt) a(i1)
                write(unit=b_str(i1),fmt=lfmt) b(i1)
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a <= b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank1_diff = .not. ( a <= b )
            unittest_error_rank1_a = a_str
            unittest_error_rank1_b = b_str
            
            if( allocated(unittest_error_rank1_extra) ) &
                deallocate(unittest_error_rank1_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " <= " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_le_integer_rank1
    subroutine precondition_le_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_le_integer_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_le_integer_rank1
    subroutine postcondition_le_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_le_integer_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_le_integer_rank1
    subroutine check_le_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_le_integer_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_le_integer_rank1
    subroutine unittest_le_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_le_integer_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_le_integer_rank1
    recursive subroutine assert_le_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:,:), allocatable :: a_str, b_str
#else
        character(:), dimension(:,:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1,i2
        type(unittest_error_rank2) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a <= b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"I10"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(a_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_le_integer_rank2)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(b_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_le_integer_rank2)"
            
            do i1=1,size(a,1)
            do i2=1,size(a,2)
                write(unit=a_str(i1,i2),fmt=lfmt) a(i1,i2)
                write(unit=b_str(i1,i2),fmt=lfmt) b(i1,i2)
            end do
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a <= b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank2_diff = .not. ( a <= b )
            unittest_error_rank2_a = a_str
            unittest_error_rank2_b = b_str
            
            if( allocated(unittest_error_rank2_extra) ) &
                deallocate(unittest_error_rank2_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " <= " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_le_integer_rank2
    subroutine precondition_le_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_le_integer_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_le_integer_rank2
    subroutine postcondition_le_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_le_integer_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_le_integer_rank2
    subroutine check_le_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_le_integer_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_le_integer_rank2
    subroutine unittest_le_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_le_integer_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_le_integer_rank2
    recursive subroutine assert_le_real_6_37_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str
#else
        character(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        type(unittest_error_rank0) :: info
        
        if( a <= b ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES13.6"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_le_real_6_37_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_le_real_6_37_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a <= b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( a <= b )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " <= " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_le_real_6_37_rank0
    subroutine precondition_le_real_6_37_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_le_real_6_37_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_le_real_6_37_rank0
    subroutine postcondition_le_real_6_37_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_le_real_6_37_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_le_real_6_37_rank0
    subroutine check_le_real_6_37_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_le_real_6_37_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_le_real_6_37_rank0
    subroutine unittest_le_real_6_37_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_le_real_6_37_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_le_real_6_37_rank0
    recursive subroutine assert_le_real_6_37_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:), allocatable :: a_str, b_str
#else
        character(:), dimension(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1
        type(unittest_error_rank1) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a <= b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES13.6"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1)),stat=stat)
#else
            allocate(a_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_le_real_6_37_rank1)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1)),stat=stat)
#else
            allocate(b_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_le_real_6_37_rank1)"
            
            do i1=1,size(a,1)
                write(unit=a_str(i1),fmt=lfmt) a(i1)
                write(unit=b_str(i1),fmt=lfmt) b(i1)
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a <= b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank1_diff = .not. ( a <= b )
            unittest_error_rank1_a = a_str
            unittest_error_rank1_b = b_str
            
            if( allocated(unittest_error_rank1_extra) ) &
                deallocate(unittest_error_rank1_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " <= " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_le_real_6_37_rank1
    subroutine precondition_le_real_6_37_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_le_real_6_37_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_le_real_6_37_rank1
    subroutine postcondition_le_real_6_37_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_le_real_6_37_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_le_real_6_37_rank1
    subroutine check_le_real_6_37_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_le_real_6_37_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_le_real_6_37_rank1
    subroutine unittest_le_real_6_37_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_le_real_6_37_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_le_real_6_37_rank1
    recursive subroutine assert_le_real_6_37_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:,:), allocatable :: a_str, b_str
#else
        character(:), dimension(:,:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1,i2
        type(unittest_error_rank2) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a <= b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES13.6"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(a_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_le_real_6_37_rank2)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(b_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_le_real_6_37_rank2)"
            
            do i1=1,size(a,1)
            do i2=1,size(a,2)
                write(unit=a_str(i1,i2),fmt=lfmt) a(i1,i2)
                write(unit=b_str(i1,i2),fmt=lfmt) b(i1,i2)
            end do
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a <= b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank2_diff = .not. ( a <= b )
            unittest_error_rank2_a = a_str
            unittest_error_rank2_b = b_str
            
            if( allocated(unittest_error_rank2_extra) ) &
                deallocate(unittest_error_rank2_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " <= " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_le_real_6_37_rank2
    subroutine precondition_le_real_6_37_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_le_real_6_37_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_le_real_6_37_rank2
    subroutine postcondition_le_real_6_37_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_le_real_6_37_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_le_real_6_37_rank2
    subroutine check_le_real_6_37_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_le_real_6_37_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_le_real_6_37_rank2
    subroutine unittest_le_real_6_37_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_le_real_6_37_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_le_real_6_37_rank2
    recursive subroutine assert_le_real_15_307_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str
#else
        character(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        type(unittest_error_rank0) :: info
        
        if( a <= b ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES22.15"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_le_real_15_307_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_le_real_15_307_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a <= b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( a <= b )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " <= " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_le_real_15_307_rank0
    subroutine precondition_le_real_15_307_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_le_real_15_307_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_le_real_15_307_rank0
    subroutine postcondition_le_real_15_307_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_le_real_15_307_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_le_real_15_307_rank0
    subroutine check_le_real_15_307_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_le_real_15_307_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_le_real_15_307_rank0
    subroutine unittest_le_real_15_307_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_le_real_15_307_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_le_real_15_307_rank0
    recursive subroutine assert_le_real_15_307_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:), allocatable :: a_str, b_str
#else
        character(:), dimension(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1
        type(unittest_error_rank1) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a <= b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES22.15"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1)),stat=stat)
#else
            allocate(a_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_le_real_15_307_rank1)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1)),stat=stat)
#else
            allocate(b_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_le_real_15_307_rank1)"
            
            do i1=1,size(a,1)
                write(unit=a_str(i1),fmt=lfmt) a(i1)
                write(unit=b_str(i1),fmt=lfmt) b(i1)
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a <= b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank1_diff = .not. ( a <= b )
            unittest_error_rank1_a = a_str
            unittest_error_rank1_b = b_str
            
            if( allocated(unittest_error_rank1_extra) ) &
                deallocate(unittest_error_rank1_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " <= " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_le_real_15_307_rank1
    subroutine precondition_le_real_15_307_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_le_real_15_307_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_le_real_15_307_rank1
    subroutine postcondition_le_real_15_307_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_le_real_15_307_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_le_real_15_307_rank1
    subroutine check_le_real_15_307_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_le_real_15_307_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_le_real_15_307_rank1
    subroutine unittest_le_real_15_307_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_le_real_15_307_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_le_real_15_307_rank1
    recursive subroutine assert_le_real_15_307_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:,:), allocatable :: a_str, b_str
#else
        character(:), dimension(:,:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1,i2
        type(unittest_error_rank2) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a <= b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES22.15"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(a_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_le_real_15_307_rank2)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(b_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_le_real_15_307_rank2)"
            
            do i1=1,size(a,1)
            do i2=1,size(a,2)
                write(unit=a_str(i1,i2),fmt=lfmt) a(i1,i2)
                write(unit=b_str(i1,i2),fmt=lfmt) b(i1,i2)
            end do
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a <= b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank2_diff = .not. ( a <= b )
            unittest_error_rank2_a = a_str
            unittest_error_rank2_b = b_str
            
            if( allocated(unittest_error_rank2_extra) ) &
                deallocate(unittest_error_rank2_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " <= " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_le_real_15_307_rank2
    subroutine precondition_le_real_15_307_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_le_real_15_307_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_le_real_15_307_rank2
    subroutine postcondition_le_real_15_307_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_le_real_15_307_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_le_real_15_307_rank2
    subroutine check_le_real_15_307_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_le_real_15_307_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_le_real_15_307_rank2
    subroutine unittest_le_real_15_307_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_le_real_15_307_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_le_real_15_307_rank2
    recursive subroutine assert_le_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str
#else
        character(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        type(unittest_error_rank0) :: info
        
        if( a <= b ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"A20"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_le_character_len_star_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_le_character_len_star_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            ! Left-align character strings
            a_str = adjustl( a_str )
            b_str = adjustl( b_str )
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a <= b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( a <= b )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " <= " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_le_character_len_star_rank0
    subroutine precondition_le_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_le_character_len_star_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_le_character_len_star_rank0
    subroutine postcondition_le_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_le_character_len_star_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_le_character_len_star_rank0
    subroutine check_le_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_le_character_len_star_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_le_character_len_star_rank0
    subroutine unittest_le_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_le_character_len_star_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_le_character_len_star_rank0

    !--------------------------------------------------------------------------
    ! Procedure assert_gt
    !--------------------------------------------------------------------------
    
    recursive subroutine assert_gt_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str
#else
        character(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        type(unittest_error_rank0) :: info
        
        if( a > b ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"I10"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_gt_integer_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_gt_integer_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a > b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( a > b )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " > " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_gt_integer_rank0
    subroutine precondition_gt_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_gt_integer_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_gt_integer_rank0
    subroutine postcondition_gt_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_gt_integer_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_gt_integer_rank0
    subroutine check_gt_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_gt_integer_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_gt_integer_rank0
    subroutine unittest_gt_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_gt_integer_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_gt_integer_rank0
    recursive subroutine assert_gt_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:), allocatable :: a_str, b_str
#else
        character(:), dimension(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1
        type(unittest_error_rank1) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a > b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"I10"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1)),stat=stat)
#else
            allocate(a_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_gt_integer_rank1)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1)),stat=stat)
#else
            allocate(b_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_gt_integer_rank1)"
            
            do i1=1,size(a,1)
                write(unit=a_str(i1),fmt=lfmt) a(i1)
                write(unit=b_str(i1),fmt=lfmt) b(i1)
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a > b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank1_diff = .not. ( a > b )
            unittest_error_rank1_a = a_str
            unittest_error_rank1_b = b_str
            
            if( allocated(unittest_error_rank1_extra) ) &
                deallocate(unittest_error_rank1_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " > " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_gt_integer_rank1
    subroutine precondition_gt_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_gt_integer_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_gt_integer_rank1
    subroutine postcondition_gt_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_gt_integer_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_gt_integer_rank1
    subroutine check_gt_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_gt_integer_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_gt_integer_rank1
    subroutine unittest_gt_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_gt_integer_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_gt_integer_rank1
    recursive subroutine assert_gt_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:,:), allocatable :: a_str, b_str
#else
        character(:), dimension(:,:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1,i2
        type(unittest_error_rank2) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a > b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"I10"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(a_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_gt_integer_rank2)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(b_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_gt_integer_rank2)"
            
            do i1=1,size(a,1)
            do i2=1,size(a,2)
                write(unit=a_str(i1,i2),fmt=lfmt) a(i1,i2)
                write(unit=b_str(i1,i2),fmt=lfmt) b(i1,i2)
            end do
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a > b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank2_diff = .not. ( a > b )
            unittest_error_rank2_a = a_str
            unittest_error_rank2_b = b_str
            
            if( allocated(unittest_error_rank2_extra) ) &
                deallocate(unittest_error_rank2_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " > " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_gt_integer_rank2
    subroutine precondition_gt_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_gt_integer_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_gt_integer_rank2
    subroutine postcondition_gt_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_gt_integer_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_gt_integer_rank2
    subroutine check_gt_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_gt_integer_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_gt_integer_rank2
    subroutine unittest_gt_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_gt_integer_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_gt_integer_rank2
    recursive subroutine assert_gt_real_6_37_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str
#else
        character(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        type(unittest_error_rank0) :: info
        
        if( a > b ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES13.6"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_gt_real_6_37_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_gt_real_6_37_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a > b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( a > b )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " > " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_gt_real_6_37_rank0
    subroutine precondition_gt_real_6_37_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_gt_real_6_37_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_gt_real_6_37_rank0
    subroutine postcondition_gt_real_6_37_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_gt_real_6_37_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_gt_real_6_37_rank0
    subroutine check_gt_real_6_37_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_gt_real_6_37_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_gt_real_6_37_rank0
    subroutine unittest_gt_real_6_37_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_gt_real_6_37_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_gt_real_6_37_rank0
    recursive subroutine assert_gt_real_6_37_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:), allocatable :: a_str, b_str
#else
        character(:), dimension(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1
        type(unittest_error_rank1) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a > b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES13.6"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1)),stat=stat)
#else
            allocate(a_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_gt_real_6_37_rank1)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1)),stat=stat)
#else
            allocate(b_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_gt_real_6_37_rank1)"
            
            do i1=1,size(a,1)
                write(unit=a_str(i1),fmt=lfmt) a(i1)
                write(unit=b_str(i1),fmt=lfmt) b(i1)
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a > b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank1_diff = .not. ( a > b )
            unittest_error_rank1_a = a_str
            unittest_error_rank1_b = b_str
            
            if( allocated(unittest_error_rank1_extra) ) &
                deallocate(unittest_error_rank1_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " > " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_gt_real_6_37_rank1
    subroutine precondition_gt_real_6_37_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_gt_real_6_37_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_gt_real_6_37_rank1
    subroutine postcondition_gt_real_6_37_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_gt_real_6_37_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_gt_real_6_37_rank1
    subroutine check_gt_real_6_37_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_gt_real_6_37_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_gt_real_6_37_rank1
    subroutine unittest_gt_real_6_37_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_gt_real_6_37_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_gt_real_6_37_rank1
    recursive subroutine assert_gt_real_6_37_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:,:), allocatable :: a_str, b_str
#else
        character(:), dimension(:,:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1,i2
        type(unittest_error_rank2) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a > b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES13.6"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(a_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_gt_real_6_37_rank2)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(b_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_gt_real_6_37_rank2)"
            
            do i1=1,size(a,1)
            do i2=1,size(a,2)
                write(unit=a_str(i1,i2),fmt=lfmt) a(i1,i2)
                write(unit=b_str(i1,i2),fmt=lfmt) b(i1,i2)
            end do
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a > b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank2_diff = .not. ( a > b )
            unittest_error_rank2_a = a_str
            unittest_error_rank2_b = b_str
            
            if( allocated(unittest_error_rank2_extra) ) &
                deallocate(unittest_error_rank2_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " > " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_gt_real_6_37_rank2
    subroutine precondition_gt_real_6_37_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_gt_real_6_37_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_gt_real_6_37_rank2
    subroutine postcondition_gt_real_6_37_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_gt_real_6_37_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_gt_real_6_37_rank2
    subroutine check_gt_real_6_37_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_gt_real_6_37_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_gt_real_6_37_rank2
    subroutine unittest_gt_real_6_37_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_gt_real_6_37_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_gt_real_6_37_rank2
    recursive subroutine assert_gt_real_15_307_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str
#else
        character(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        type(unittest_error_rank0) :: info
        
        if( a > b ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES22.15"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_gt_real_15_307_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_gt_real_15_307_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a > b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( a > b )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " > " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_gt_real_15_307_rank0
    subroutine precondition_gt_real_15_307_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_gt_real_15_307_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_gt_real_15_307_rank0
    subroutine postcondition_gt_real_15_307_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_gt_real_15_307_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_gt_real_15_307_rank0
    subroutine check_gt_real_15_307_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_gt_real_15_307_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_gt_real_15_307_rank0
    subroutine unittest_gt_real_15_307_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_gt_real_15_307_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_gt_real_15_307_rank0
    recursive subroutine assert_gt_real_15_307_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:), allocatable :: a_str, b_str
#else
        character(:), dimension(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1
        type(unittest_error_rank1) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a > b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES22.15"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1)),stat=stat)
#else
            allocate(a_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_gt_real_15_307_rank1)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1)),stat=stat)
#else
            allocate(b_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_gt_real_15_307_rank1)"
            
            do i1=1,size(a,1)
                write(unit=a_str(i1),fmt=lfmt) a(i1)
                write(unit=b_str(i1),fmt=lfmt) b(i1)
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a > b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank1_diff = .not. ( a > b )
            unittest_error_rank1_a = a_str
            unittest_error_rank1_b = b_str
            
            if( allocated(unittest_error_rank1_extra) ) &
                deallocate(unittest_error_rank1_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " > " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_gt_real_15_307_rank1
    subroutine precondition_gt_real_15_307_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_gt_real_15_307_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_gt_real_15_307_rank1
    subroutine postcondition_gt_real_15_307_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_gt_real_15_307_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_gt_real_15_307_rank1
    subroutine check_gt_real_15_307_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_gt_real_15_307_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_gt_real_15_307_rank1
    subroutine unittest_gt_real_15_307_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_gt_real_15_307_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_gt_real_15_307_rank1
    recursive subroutine assert_gt_real_15_307_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:,:), allocatable :: a_str, b_str
#else
        character(:), dimension(:,:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1,i2
        type(unittest_error_rank2) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a > b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES22.15"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(a_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_gt_real_15_307_rank2)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(b_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_gt_real_15_307_rank2)"
            
            do i1=1,size(a,1)
            do i2=1,size(a,2)
                write(unit=a_str(i1,i2),fmt=lfmt) a(i1,i2)
                write(unit=b_str(i1,i2),fmt=lfmt) b(i1,i2)
            end do
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a > b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank2_diff = .not. ( a > b )
            unittest_error_rank2_a = a_str
            unittest_error_rank2_b = b_str
            
            if( allocated(unittest_error_rank2_extra) ) &
                deallocate(unittest_error_rank2_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " > " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_gt_real_15_307_rank2
    subroutine precondition_gt_real_15_307_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_gt_real_15_307_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_gt_real_15_307_rank2
    subroutine postcondition_gt_real_15_307_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_gt_real_15_307_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_gt_real_15_307_rank2
    subroutine check_gt_real_15_307_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_gt_real_15_307_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_gt_real_15_307_rank2
    subroutine unittest_gt_real_15_307_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_gt_real_15_307_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_gt_real_15_307_rank2
    recursive subroutine assert_gt_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str
#else
        character(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        type(unittest_error_rank0) :: info
        
        if( a > b ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"A20"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_gt_character_len_star_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_gt_character_len_star_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            ! Left-align character strings
            a_str = adjustl( a_str )
            b_str = adjustl( b_str )
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a > b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( a > b )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " > " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_gt_character_len_star_rank0
    subroutine precondition_gt_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_gt_character_len_star_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_gt_character_len_star_rank0
    subroutine postcondition_gt_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_gt_character_len_star_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_gt_character_len_star_rank0
    subroutine check_gt_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_gt_character_len_star_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_gt_character_len_star_rank0
    subroutine unittest_gt_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_gt_character_len_star_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_gt_character_len_star_rank0

    !--------------------------------------------------------------------------
    ! Procedure assert_ge
    !--------------------------------------------------------------------------
    
    recursive subroutine assert_ge_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str
#else
        character(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        type(unittest_error_rank0) :: info
        
        if( a >= b ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"I10"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_ge_integer_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_ge_integer_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a >= b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( a >= b )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " >= " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_ge_integer_rank0
    subroutine precondition_ge_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_ge_integer_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_ge_integer_rank0
    subroutine postcondition_ge_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_ge_integer_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_ge_integer_rank0
    subroutine check_ge_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_ge_integer_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_ge_integer_rank0
    subroutine unittest_ge_integer_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_ge_integer_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_ge_integer_rank0
    recursive subroutine assert_ge_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:), allocatable :: a_str, b_str
#else
        character(:), dimension(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1
        type(unittest_error_rank1) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a >= b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"I10"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1)),stat=stat)
#else
            allocate(a_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_ge_integer_rank1)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1)),stat=stat)
#else
            allocate(b_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_ge_integer_rank1)"
            
            do i1=1,size(a,1)
                write(unit=a_str(i1),fmt=lfmt) a(i1)
                write(unit=b_str(i1),fmt=lfmt) b(i1)
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a >= b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank1_diff = .not. ( a >= b )
            unittest_error_rank1_a = a_str
            unittest_error_rank1_b = b_str
            
            if( allocated(unittest_error_rank1_extra) ) &
                deallocate(unittest_error_rank1_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " >= " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_ge_integer_rank1
    subroutine precondition_ge_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_ge_integer_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_ge_integer_rank1
    subroutine postcondition_ge_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_ge_integer_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_ge_integer_rank1
    subroutine check_ge_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_ge_integer_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_ge_integer_rank1
    subroutine unittest_ge_integer_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_ge_integer_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_ge_integer_rank1
    recursive subroutine assert_ge_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:,:), allocatable :: a_str, b_str
#else
        character(:), dimension(:,:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1,i2
        type(unittest_error_rank2) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a >= b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"I10"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(a_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_ge_integer_rank2)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(b_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_ge_integer_rank2)"
            
            do i1=1,size(a,1)
            do i2=1,size(a,2)
                write(unit=a_str(i1,i2),fmt=lfmt) a(i1,i2)
                write(unit=b_str(i1,i2),fmt=lfmt) b(i1,i2)
            end do
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a >= b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank2_diff = .not. ( a >= b )
            unittest_error_rank2_a = a_str
            unittest_error_rank2_b = b_str
            
            if( allocated(unittest_error_rank2_extra) ) &
                deallocate(unittest_error_rank2_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " >= " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_ge_integer_rank2
    subroutine precondition_ge_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_ge_integer_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_ge_integer_rank2
    subroutine postcondition_ge_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_ge_integer_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_ge_integer_rank2
    subroutine check_ge_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_ge_integer_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_ge_integer_rank2
    subroutine unittest_ge_integer_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_ge_integer_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_ge_integer_rank2
    recursive subroutine assert_ge_real_6_37_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str
#else
        character(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        type(unittest_error_rank0) :: info
        
        if( a >= b ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES13.6"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_ge_real_6_37_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_ge_real_6_37_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a >= b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( a >= b )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " >= " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_ge_real_6_37_rank0
    subroutine precondition_ge_real_6_37_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_ge_real_6_37_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_ge_real_6_37_rank0
    subroutine postcondition_ge_real_6_37_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_ge_real_6_37_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_ge_real_6_37_rank0
    subroutine check_ge_real_6_37_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_ge_real_6_37_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_ge_real_6_37_rank0
    subroutine unittest_ge_real_6_37_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_ge_real_6_37_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_ge_real_6_37_rank0
    recursive subroutine assert_ge_real_6_37_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:), allocatable :: a_str, b_str
#else
        character(:), dimension(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1
        type(unittest_error_rank1) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a >= b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES13.6"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1)),stat=stat)
#else
            allocate(a_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_ge_real_6_37_rank1)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1)),stat=stat)
#else
            allocate(b_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_ge_real_6_37_rank1)"
            
            do i1=1,size(a,1)
                write(unit=a_str(i1),fmt=lfmt) a(i1)
                write(unit=b_str(i1),fmt=lfmt) b(i1)
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a >= b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank1_diff = .not. ( a >= b )
            unittest_error_rank1_a = a_str
            unittest_error_rank1_b = b_str
            
            if( allocated(unittest_error_rank1_extra) ) &
                deallocate(unittest_error_rank1_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " >= " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_ge_real_6_37_rank1
    subroutine precondition_ge_real_6_37_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_ge_real_6_37_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_ge_real_6_37_rank1
    subroutine postcondition_ge_real_6_37_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_ge_real_6_37_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_ge_real_6_37_rank1
    subroutine check_ge_real_6_37_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_ge_real_6_37_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_ge_real_6_37_rank1
    subroutine unittest_ge_real_6_37_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_ge_real_6_37_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_ge_real_6_37_rank1
    recursive subroutine assert_ge_real_6_37_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:,:), allocatable :: a_str, b_str
#else
        character(:), dimension(:,:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1,i2
        type(unittest_error_rank2) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a >= b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES13.6"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(a_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_ge_real_6_37_rank2)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(b_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_ge_real_6_37_rank2)"
            
            do i1=1,size(a,1)
            do i2=1,size(a,2)
                write(unit=a_str(i1,i2),fmt=lfmt) a(i1,i2)
                write(unit=b_str(i1,i2),fmt=lfmt) b(i1,i2)
            end do
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a >= b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank2_diff = .not. ( a >= b )
            unittest_error_rank2_a = a_str
            unittest_error_rank2_b = b_str
            
            if( allocated(unittest_error_rank2_extra) ) &
                deallocate(unittest_error_rank2_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " >= " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_ge_real_6_37_rank2
    subroutine precondition_ge_real_6_37_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_ge_real_6_37_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_ge_real_6_37_rank2
    subroutine postcondition_ge_real_6_37_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_ge_real_6_37_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_ge_real_6_37_rank2
    subroutine check_ge_real_6_37_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_ge_real_6_37_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_ge_real_6_37_rank2
    subroutine unittest_ge_real_6_37_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_ge_real_6_37_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_ge_real_6_37_rank2
    recursive subroutine assert_ge_real_15_307_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str
#else
        character(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        type(unittest_error_rank0) :: info
        
        if( a >= b ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES22.15"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_ge_real_15_307_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_ge_real_15_307_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a >= b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( a >= b )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " >= " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_ge_real_15_307_rank0
    subroutine precondition_ge_real_15_307_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_ge_real_15_307_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_ge_real_15_307_rank0
    subroutine postcondition_ge_real_15_307_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_ge_real_15_307_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_ge_real_15_307_rank0
    subroutine check_ge_real_15_307_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_ge_real_15_307_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_ge_real_15_307_rank0
    subroutine unittest_ge_real_15_307_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_ge_real_15_307_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_ge_real_15_307_rank0
    recursive subroutine assert_ge_real_15_307_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:), allocatable :: a_str, b_str
#else
        character(:), dimension(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1
        type(unittest_error_rank1) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a >= b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES22.15"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1)),stat=stat)
#else
            allocate(a_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_ge_real_15_307_rank1)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1)),stat=stat)
#else
            allocate(b_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_ge_real_15_307_rank1)"
            
            do i1=1,size(a,1)
                write(unit=a_str(i1),fmt=lfmt) a(i1)
                write(unit=b_str(i1),fmt=lfmt) b(i1)
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a >= b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank1_diff = .not. ( a >= b )
            unittest_error_rank1_a = a_str
            unittest_error_rank1_b = b_str
            
            if( allocated(unittest_error_rank1_extra) ) &
                deallocate(unittest_error_rank1_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " >= " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_ge_real_15_307_rank1
    subroutine precondition_ge_real_15_307_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_ge_real_15_307_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_ge_real_15_307_rank1
    subroutine postcondition_ge_real_15_307_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_ge_real_15_307_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_ge_real_15_307_rank1
    subroutine check_ge_real_15_307_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_ge_real_15_307_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_ge_real_15_307_rank1
    subroutine unittest_ge_real_15_307_rank1( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_ge_real_15_307_rank1( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_ge_real_15_307_rank1
    recursive subroutine assert_ge_real_15_307_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:,:), allocatable :: a_str, b_str
#else
        character(:), dimension(:,:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        integer :: i1,i2
        type(unittest_error_rank2) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        if( all( a >= b ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES22.15"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(a_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_ge_real_15_307_rank2)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(b_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_ge_real_15_307_rank2)"
            
            do i1=1,size(a,1)
            do i2=1,size(a,2)
                write(unit=a_str(i1,i2),fmt=lfmt) a(i1,i2)
                write(unit=b_str(i1,i2),fmt=lfmt) b(i1,i2)
            end do
            end do
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a >= b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank2_diff = .not. ( a >= b )
            unittest_error_rank2_a = a_str
            unittest_error_rank2_b = b_str
            
            if( allocated(unittest_error_rank2_extra) ) &
                deallocate(unittest_error_rank2_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " >= " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_ge_real_15_307_rank2
    subroutine precondition_ge_real_15_307_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_ge_real_15_307_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_ge_real_15_307_rank2
    subroutine postcondition_ge_real_15_307_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_ge_real_15_307_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_ge_real_15_307_rank2
    subroutine check_ge_real_15_307_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_ge_real_15_307_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_ge_real_15_307_rank2
    subroutine unittest_ge_real_15_307_rank2( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_ge_real_15_307_rank2( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_ge_real_15_307_rank2
    recursive subroutine assert_ge_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str
#else
        character(:), allocatable :: a_str, b_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        
        type(unittest_error_rank0) :: info
        
        if( a >= b ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"A20"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_ge_character_len_star_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_ge_character_len_star_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            ! Left-align character strings
            a_str = adjustl( a_str )
            b_str = adjustl( b_str )
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( a >= b )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( a >= b )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, trim(info%a_name) // " >= " // trim(info%b_name) )
            
            ! TODO: check class invariants info
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_ge_character_len_star_rank0
    subroutine precondition_ge_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_precondition() ) return
        call assert_ge_character_len_star_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_ge_character_len_star_rank0
    subroutine postcondition_ge_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_postcondition() ) return
        call assert_ge_character_len_star_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_ge_character_len_star_rank0
    subroutine check_ge_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        if( skip_check() ) return
        call assert_ge_character_len_star_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_ge_character_len_star_rank0
    subroutine unittest_ge_character_len_star_rank0( a, b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_ge_character_len_star_rank0( a,b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_ge_character_len_star_rank0

    !--------------------------------------------------------------------------
    ! Procedure abserr
    ! 
    ! These functions never cause floating point errors (i.e., inf-inf)
    !--------------------------------------------------------------------------
    
    function abserr_real_6_37_rank0( a,b ) result( abs_err )
        real(kind=selected_real_kind(6,37)), intent(in) :: a
        real(kind=selected_real_kind(6,37)), intent(in) :: b
        real(kind=selected_real_kind(6,37)) :: abs_err
        if( a/=b ) then
            abs_err = abs(a-b)
        else
            abs_err = 0
        end if
    end function abserr_real_6_37_rank0
    function abserr_real_6_37_rank1( a,b ) result( abs_err )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a
        real(kind=selected_real_kind(6,37)), dimension(size(a,1)), intent(in) :: b
        real(kind=selected_real_kind(6,37)), dimension(size(a,1)) :: abs_err
        where( a/=b )
            abs_err = abs(a-b)
        elsewhere
            abs_err = 0
        end where
    end function abserr_real_6_37_rank1
    function abserr_real_6_37_rank2( a,b ) result( abs_err )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a
        real(kind=selected_real_kind(6,37)), dimension(size(a,1),size(a,2)), intent(in) :: b
        real(kind=selected_real_kind(6,37)), dimension(size(a,1),size(a,2)) :: abs_err
        where( a/=b )
            abs_err = abs(a-b)
        elsewhere
            abs_err = 0
        end where
    end function abserr_real_6_37_rank2
    function abserr_real_15_307_rank0( a,b ) result( abs_err )
        real(kind=selected_real_kind(15,307)), intent(in) :: a
        real(kind=selected_real_kind(15,307)), intent(in) :: b
        real(kind=selected_real_kind(15,307)) :: abs_err
        if( a/=b ) then
            abs_err = abs(a-b)
        else
            abs_err = 0
        end if
    end function abserr_real_15_307_rank0
    function abserr_real_15_307_rank1( a,b ) result( abs_err )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a
        real(kind=selected_real_kind(15,307)), dimension(size(a,1)), intent(in) :: b
        real(kind=selected_real_kind(15,307)), dimension(size(a,1)) :: abs_err
        where( a/=b )
            abs_err = abs(a-b)
        elsewhere
            abs_err = 0
        end where
    end function abserr_real_15_307_rank1
    function abserr_real_15_307_rank2( a,b ) result( abs_err )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a
        real(kind=selected_real_kind(15,307)), dimension(size(a,1),size(a,2)), intent(in) :: b
        real(kind=selected_real_kind(15,307)), dimension(size(a,1),size(a,2)) :: abs_err
        where( a/=b )
            abs_err = abs(a-b)
        elsewhere
            abs_err = 0
        end where
    end function abserr_real_15_307_rank2

    !--------------------------------------------------------------------------
    ! Procedure assert_abserr
    !--------------------------------------------------------------------------
    
    subroutine assert_abserr_real_6_37_rank0( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str, e_str
#else
        character(:), allocatable :: a_str, b_str, e_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        real(kind=selected_real_kind(6,37)) :: e
        character(len=40) :: epsabs_str
        
        type(unittest_error_rank0) :: info
        
        e = abserr(a,b)
        if( e <= epsabs ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES13.6"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_abserr_real_6_37_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_abserr_real_6_37_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(e_str,stat=stat)
#else
            allocate(e_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "e_str, lfmt_width=", &
                lfmt_width, " (assert_abserr_real_6_37_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            write(unit=e_str,fmt=lfmt) e
            
            write(unit=epsabs_str,fmt="(ES8.1)") epsabs
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( e <= epsabs )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( e <= epsabs )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, &
                    "|" // trim(info%a_name) // "-" // trim(info%b_name) // "| <= " // epsabs_str )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%extra = e_str
#else
            unittest_error_rank0_extra = e_str
#endif
            info%extra_name = "abserr"
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_abserr_real_6_37_rank0
    subroutine precondition_abserr_real_6_37_rank0( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_precondition() ) return
        call assert_abserr_real_6_37_rank0( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_abserr_real_6_37_rank0
    subroutine postcondition_abserr_real_6_37_rank0( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_postcondition() ) return
        call assert_abserr_real_6_37_rank0( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_abserr_real_6_37_rank0
    subroutine check_abserr_real_6_37_rank0( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_check() ) return
        call assert_abserr_real_6_37_rank0( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_abserr_real_6_37_rank0
    subroutine unittest_abserr_real_6_37_rank0( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_abserr_real_6_37_rank0( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_abserr_real_6_37_rank0
    subroutine assert_abserr_real_6_37_rank1( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:), allocatable :: a_str, b_str, e_str
#else
        character(:), dimension(:), allocatable :: a_str, b_str, e_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        real(kind=selected_real_kind(6,37)), dimension(size(a,1)) :: e
        character(len=40) :: epsabs_str
        
        integer :: i1
        type(unittest_error_rank1) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        e = abserr(a,b)
        if( all( e <= epsabs ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES13.6"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1)),stat=stat)
#else
            allocate(a_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_abserr_real_6_37_rank1)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1)),stat=stat)
#else
            allocate(b_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_abserr_real_6_37_rank1)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(e_str(size(a,1)),stat=stat)
#else
            allocate(e_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "e_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_abserr_real_6_37_rank1)"
            
            do i1=1,size(a,1)
                write(unit=a_str(i1),fmt=lfmt) a(i1)
                write(unit=b_str(i1),fmt=lfmt) b(i1)
                write(unit=e_str(i1),fmt=lfmt) e(i1)
            end do
            
            write(unit=epsabs_str,fmt="(ES8.1)") epsabs
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( e <= epsabs )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank1_diff = .not. ( e <= epsabs )
            unittest_error_rank1_a = a_str
            unittest_error_rank1_b = b_str
            
            if( allocated(unittest_error_rank1_extra) ) &
                deallocate(unittest_error_rank1_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, &
                    "|" // trim(info%a_name) // "-" // trim(info%b_name) // "| <= " // epsabs_str )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%extra = e_str
#else
            unittest_error_rank1_extra = e_str
#endif
            info%extra_name = "abserr"
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_abserr_real_6_37_rank1
    subroutine precondition_abserr_real_6_37_rank1( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_precondition() ) return
        call assert_abserr_real_6_37_rank1( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_abserr_real_6_37_rank1
    subroutine postcondition_abserr_real_6_37_rank1( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_postcondition() ) return
        call assert_abserr_real_6_37_rank1( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_abserr_real_6_37_rank1
    subroutine check_abserr_real_6_37_rank1( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_check() ) return
        call assert_abserr_real_6_37_rank1( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_abserr_real_6_37_rank1
    subroutine unittest_abserr_real_6_37_rank1( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_abserr_real_6_37_rank1( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_abserr_real_6_37_rank1
    subroutine assert_abserr_real_6_37_rank2( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:,:), allocatable :: a_str, b_str, e_str
#else
        character(:), dimension(:,:), allocatable :: a_str, b_str, e_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        real(kind=selected_real_kind(6,37)), dimension(size(a,1),size(a,2)) :: e
        character(len=40) :: epsabs_str
        
        integer :: i1,i2
        type(unittest_error_rank2) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        e = abserr(a,b)
        if( all( e <= epsabs ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES13.6"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(a_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_abserr_real_6_37_rank2)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(b_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_abserr_real_6_37_rank2)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(e_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(e_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "e_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_abserr_real_6_37_rank2)"
            
            do i1=1,size(a,1)
            do i2=1,size(a,2)
                write(unit=a_str(i1,i2),fmt=lfmt) a(i1,i2)
                write(unit=b_str(i1,i2),fmt=lfmt) b(i1,i2)
                write(unit=e_str(i1,i2),fmt=lfmt) e(i1,i2)
            end do
            end do
            
            write(unit=epsabs_str,fmt="(ES8.1)") epsabs
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( e <= epsabs )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank2_diff = .not. ( e <= epsabs )
            unittest_error_rank2_a = a_str
            unittest_error_rank2_b = b_str
            
            if( allocated(unittest_error_rank2_extra) ) &
                deallocate(unittest_error_rank2_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, &
                    "|" // trim(info%a_name) // "-" // trim(info%b_name) // "| <= " // epsabs_str )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%extra = e_str
#else
            unittest_error_rank2_extra = e_str
#endif
            info%extra_name = "abserr"
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_abserr_real_6_37_rank2
    subroutine precondition_abserr_real_6_37_rank2( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_precondition() ) return
        call assert_abserr_real_6_37_rank2( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_abserr_real_6_37_rank2
    subroutine postcondition_abserr_real_6_37_rank2( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_postcondition() ) return
        call assert_abserr_real_6_37_rank2( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_abserr_real_6_37_rank2
    subroutine check_abserr_real_6_37_rank2( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_check() ) return
        call assert_abserr_real_6_37_rank2( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_abserr_real_6_37_rank2
    subroutine unittest_abserr_real_6_37_rank2( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_abserr_real_6_37_rank2( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_abserr_real_6_37_rank2
    subroutine assert_abserr_real_15_307_rank0( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str, e_str
#else
        character(:), allocatable :: a_str, b_str, e_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        real(kind=selected_real_kind(15,307)) :: e
        character(len=40) :: epsabs_str
        
        type(unittest_error_rank0) :: info
        
        e = abserr(a,b)
        if( e <= epsabs ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES22.15"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_abserr_real_15_307_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_abserr_real_15_307_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(e_str,stat=stat)
#else
            allocate(e_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "e_str, lfmt_width=", &
                lfmt_width, " (assert_abserr_real_15_307_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            write(unit=e_str,fmt=lfmt) e
            
            write(unit=epsabs_str,fmt="(ES8.1)") epsabs
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( e <= epsabs )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( e <= epsabs )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, &
                    "|" // trim(info%a_name) // "-" // trim(info%b_name) // "| <= " // epsabs_str )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%extra = e_str
#else
            unittest_error_rank0_extra = e_str
#endif
            info%extra_name = "abserr"
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_abserr_real_15_307_rank0
    subroutine precondition_abserr_real_15_307_rank0( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_precondition() ) return
        call assert_abserr_real_15_307_rank0( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_abserr_real_15_307_rank0
    subroutine postcondition_abserr_real_15_307_rank0( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_postcondition() ) return
        call assert_abserr_real_15_307_rank0( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_abserr_real_15_307_rank0
    subroutine check_abserr_real_15_307_rank0( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_check() ) return
        call assert_abserr_real_15_307_rank0( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_abserr_real_15_307_rank0
    subroutine unittest_abserr_real_15_307_rank0( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_abserr_real_15_307_rank0( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_abserr_real_15_307_rank0
    subroutine assert_abserr_real_15_307_rank1( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:), allocatable :: a_str, b_str, e_str
#else
        character(:), dimension(:), allocatable :: a_str, b_str, e_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        real(kind=selected_real_kind(15,307)), dimension(size(a,1)) :: e
        character(len=40) :: epsabs_str
        
        integer :: i1
        type(unittest_error_rank1) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        e = abserr(a,b)
        if( all( e <= epsabs ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES22.15"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1)),stat=stat)
#else
            allocate(a_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_abserr_real_15_307_rank1)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1)),stat=stat)
#else
            allocate(b_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_abserr_real_15_307_rank1)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(e_str(size(a,1)),stat=stat)
#else
            allocate(e_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "e_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_abserr_real_15_307_rank1)"
            
            do i1=1,size(a,1)
                write(unit=a_str(i1),fmt=lfmt) a(i1)
                write(unit=b_str(i1),fmt=lfmt) b(i1)
                write(unit=e_str(i1),fmt=lfmt) e(i1)
            end do
            
            write(unit=epsabs_str,fmt="(ES8.1)") epsabs
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( e <= epsabs )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank1_diff = .not. ( e <= epsabs )
            unittest_error_rank1_a = a_str
            unittest_error_rank1_b = b_str
            
            if( allocated(unittest_error_rank1_extra) ) &
                deallocate(unittest_error_rank1_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, &
                    "|" // trim(info%a_name) // "-" // trim(info%b_name) // "| <= " // epsabs_str )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%extra = e_str
#else
            unittest_error_rank1_extra = e_str
#endif
            info%extra_name = "abserr"
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_abserr_real_15_307_rank1
    subroutine precondition_abserr_real_15_307_rank1( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_precondition() ) return
        call assert_abserr_real_15_307_rank1( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_abserr_real_15_307_rank1
    subroutine postcondition_abserr_real_15_307_rank1( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_postcondition() ) return
        call assert_abserr_real_15_307_rank1( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_abserr_real_15_307_rank1
    subroutine check_abserr_real_15_307_rank1( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_check() ) return
        call assert_abserr_real_15_307_rank1( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_abserr_real_15_307_rank1
    subroutine unittest_abserr_real_15_307_rank1( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_abserr_real_15_307_rank1( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_abserr_real_15_307_rank1
    subroutine assert_abserr_real_15_307_rank2( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:,:), allocatable :: a_str, b_str, e_str
#else
        character(:), dimension(:,:), allocatable :: a_str, b_str, e_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        real(kind=selected_real_kind(15,307)), dimension(size(a,1),size(a,2)) :: e
        character(len=40) :: epsabs_str
        
        integer :: i1,i2
        type(unittest_error_rank2) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        e = abserr(a,b)
        if( all( e <= epsabs ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES22.15"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(a_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_abserr_real_15_307_rank2)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(b_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_abserr_real_15_307_rank2)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(e_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(e_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "e_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_abserr_real_15_307_rank2)"
            
            do i1=1,size(a,1)
            do i2=1,size(a,2)
                write(unit=a_str(i1,i2),fmt=lfmt) a(i1,i2)
                write(unit=b_str(i1,i2),fmt=lfmt) b(i1,i2)
                write(unit=e_str(i1,i2),fmt=lfmt) e(i1,i2)
            end do
            end do
            
            write(unit=epsabs_str,fmt="(ES8.1)") epsabs
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( e <= epsabs )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank2_diff = .not. ( e <= epsabs )
            unittest_error_rank2_a = a_str
            unittest_error_rank2_b = b_str
            
            if( allocated(unittest_error_rank2_extra) ) &
                deallocate(unittest_error_rank2_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, &
                    "|" // trim(info%a_name) // "-" // trim(info%b_name) // "| <= " // epsabs_str )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%extra = e_str
#else
            unittest_error_rank2_extra = e_str
#endif
            info%extra_name = "abserr"
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_abserr_real_15_307_rank2
    subroutine precondition_abserr_real_15_307_rank2( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_precondition() ) return
        call assert_abserr_real_15_307_rank2( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_abserr_real_15_307_rank2
    subroutine postcondition_abserr_real_15_307_rank2( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_postcondition() ) return
        call assert_abserr_real_15_307_rank2( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_abserr_real_15_307_rank2
    subroutine check_abserr_real_15_307_rank2( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_check() ) return
        call assert_abserr_real_15_307_rank2( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_abserr_real_15_307_rank2
    subroutine unittest_abserr_real_15_307_rank2( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_abserr_real_15_307_rank2( a, b, epsabs, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_abserr_real_15_307_rank2

    !--------------------------------------------------------------------------
    ! Procedure relerr
    ! 
    ! These functions never cause floating point errors (i.e., inf-inf)
    !--------------------------------------------------------------------------
    
    function relerr_real_6_37_rank0( a,b ) result( rel_err )
        real(kind=selected_real_kind(6,37)), intent(in) :: a
        real(kind=selected_real_kind(6,37)), intent(in) :: b
        real(kind=selected_real_kind(6,37)) :: rel_err
        if( a/=b ) then
            rel_err = abs((a-b)/a)
        else
            rel_err = 0
        end if
    end function relerr_real_6_37_rank0
    function relerr_real_6_37_rank1( a,b ) result( rel_err )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a
        real(kind=selected_real_kind(6,37)), dimension(size(a,1)), intent(in) :: b
        real(kind=selected_real_kind(6,37)), dimension(size(a,1)) :: rel_err
        where( a/=b )
            rel_err = abs((a-b)/a)
        elsewhere
            rel_err = 0
        end where
    end function relerr_real_6_37_rank1
    function relerr_real_6_37_rank2( a,b ) result( rel_err )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a
        real(kind=selected_real_kind(6,37)), dimension(size(a,1),size(a,2)), intent(in) :: b
        real(kind=selected_real_kind(6,37)), dimension(size(a,1),size(a,2)) :: rel_err
        where( a/=b )
            rel_err = abs((a-b)/a)
        elsewhere
            rel_err = 0
        end where
    end function relerr_real_6_37_rank2
    function relerr_real_15_307_rank0( a,b ) result( rel_err )
        real(kind=selected_real_kind(15,307)), intent(in) :: a
        real(kind=selected_real_kind(15,307)), intent(in) :: b
        real(kind=selected_real_kind(15,307)) :: rel_err
        if( a/=b ) then
            rel_err = abs((a-b)/a)
        else
            rel_err = 0
        end if
    end function relerr_real_15_307_rank0
    function relerr_real_15_307_rank1( a,b ) result( rel_err )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a
        real(kind=selected_real_kind(15,307)), dimension(size(a,1)), intent(in) :: b
        real(kind=selected_real_kind(15,307)), dimension(size(a,1)) :: rel_err
        where( a/=b )
            rel_err = abs((a-b)/a)
        elsewhere
            rel_err = 0
        end where
    end function relerr_real_15_307_rank1
    function relerr_real_15_307_rank2( a,b ) result( rel_err )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a
        real(kind=selected_real_kind(15,307)), dimension(size(a,1),size(a,2)), intent(in) :: b
        real(kind=selected_real_kind(15,307)), dimension(size(a,1),size(a,2)) :: rel_err
        where( a/=b )
            rel_err = abs((a-b)/a)
        elsewhere
            rel_err = 0
        end where
    end function relerr_real_15_307_rank2

    !--------------------------------------------------------------------------
    ! Procedure assert_relerr
    !--------------------------------------------------------------------------
    
    subroutine assert_relerr_real_6_37_rank0( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str, e_str
#else
        character(:), allocatable :: a_str, b_str, e_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        real(kind=selected_real_kind(6,37)) :: e
        character(len=40) :: epsrel_str
        
        type(unittest_error_rank0) :: info
        
        e = relerr(a,b)
        if( e <= epsrel ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES13.6"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_relerr_real_6_37_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_relerr_real_6_37_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(e_str,stat=stat)
#else
            allocate(e_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "e_str, lfmt_width=", &
                lfmt_width, " (assert_relerr_real_6_37_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            write(unit=e_str,fmt=lfmt) e
            
            write(unit=epsrel_str,fmt="(ES8.1)") epsrel
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( e <= epsrel )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( e <= epsrel )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, &
                    "|(" // trim(info%a_name) // "-" // trim(info%b_name) // ")/" // trim(info%a_name) // "| <= " // epsrel_str )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%extra = e_str
#else
            unittest_error_rank0_extra = e_str
#endif
            info%extra_name = "relerr"
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_relerr_real_6_37_rank0
    subroutine precondition_relerr_real_6_37_rank0( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_precondition() ) return
        call assert_relerr_real_6_37_rank0( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_relerr_real_6_37_rank0
    subroutine postcondition_relerr_real_6_37_rank0( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_postcondition() ) return
        call assert_relerr_real_6_37_rank0( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_relerr_real_6_37_rank0
    subroutine check_relerr_real_6_37_rank0( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_check() ) return
        call assert_relerr_real_6_37_rank0( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_relerr_real_6_37_rank0
    subroutine unittest_relerr_real_6_37_rank0( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_relerr_real_6_37_rank0( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_relerr_real_6_37_rank0
    subroutine assert_relerr_real_6_37_rank1( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:), allocatable :: a_str, b_str, e_str
#else
        character(:), dimension(:), allocatable :: a_str, b_str, e_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        real(kind=selected_real_kind(6,37)), dimension(size(a,1)) :: e
        character(len=40) :: epsrel_str
        
        integer :: i1
        type(unittest_error_rank1) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        e = relerr(a,b)
        if( all( e <= epsrel ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES13.6"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1)),stat=stat)
#else
            allocate(a_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_relerr_real_6_37_rank1)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1)),stat=stat)
#else
            allocate(b_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_relerr_real_6_37_rank1)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(e_str(size(a,1)),stat=stat)
#else
            allocate(e_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "e_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_relerr_real_6_37_rank1)"
            
            do i1=1,size(a,1)
                write(unit=a_str(i1),fmt=lfmt) a(i1)
                write(unit=b_str(i1),fmt=lfmt) b(i1)
                write(unit=e_str(i1),fmt=lfmt) e(i1)
            end do
            
            write(unit=epsrel_str,fmt="(ES8.1)") epsrel
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( e <= epsrel )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank1_diff = .not. ( e <= epsrel )
            unittest_error_rank1_a = a_str
            unittest_error_rank1_b = b_str
            
            if( allocated(unittest_error_rank1_extra) ) &
                deallocate(unittest_error_rank1_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, &
                    "|(" // trim(info%a_name) // "-" // trim(info%b_name) // ")/" // trim(info%a_name) // "| <= " // epsrel_str )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%extra = e_str
#else
            unittest_error_rank1_extra = e_str
#endif
            info%extra_name = "relerr"
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_relerr_real_6_37_rank1
    subroutine precondition_relerr_real_6_37_rank1( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_precondition() ) return
        call assert_relerr_real_6_37_rank1( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_relerr_real_6_37_rank1
    subroutine postcondition_relerr_real_6_37_rank1( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_postcondition() ) return
        call assert_relerr_real_6_37_rank1( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_relerr_real_6_37_rank1
    subroutine check_relerr_real_6_37_rank1( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_check() ) return
        call assert_relerr_real_6_37_rank1( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_relerr_real_6_37_rank1
    subroutine unittest_relerr_real_6_37_rank1( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_relerr_real_6_37_rank1( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_relerr_real_6_37_rank1
    subroutine assert_relerr_real_6_37_rank2( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:,:), allocatable :: a_str, b_str, e_str
#else
        character(:), dimension(:,:), allocatable :: a_str, b_str, e_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        real(kind=selected_real_kind(6,37)), dimension(size(a,1),size(a,2)) :: e
        character(len=40) :: epsrel_str
        
        integer :: i1,i2
        type(unittest_error_rank2) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        e = relerr(a,b)
        if( all( e <= epsrel ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES13.6"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(a_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_relerr_real_6_37_rank2)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(b_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_relerr_real_6_37_rank2)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(e_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(e_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "e_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_relerr_real_6_37_rank2)"
            
            do i1=1,size(a,1)
            do i2=1,size(a,2)
                write(unit=a_str(i1,i2),fmt=lfmt) a(i1,i2)
                write(unit=b_str(i1,i2),fmt=lfmt) b(i1,i2)
                write(unit=e_str(i1,i2),fmt=lfmt) e(i1,i2)
            end do
            end do
            
            write(unit=epsrel_str,fmt="(ES8.1)") epsrel
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( e <= epsrel )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank2_diff = .not. ( e <= epsrel )
            unittest_error_rank2_a = a_str
            unittest_error_rank2_b = b_str
            
            if( allocated(unittest_error_rank2_extra) ) &
                deallocate(unittest_error_rank2_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, &
                    "|(" // trim(info%a_name) // "-" // trim(info%b_name) // ")/" // trim(info%a_name) // "| <= " // epsrel_str )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%extra = e_str
#else
            unittest_error_rank2_extra = e_str
#endif
            info%extra_name = "relerr"
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_relerr_real_6_37_rank2
    subroutine precondition_relerr_real_6_37_rank2( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_precondition() ) return
        call assert_relerr_real_6_37_rank2( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_relerr_real_6_37_rank2
    subroutine postcondition_relerr_real_6_37_rank2( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_postcondition() ) return
        call assert_relerr_real_6_37_rank2( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_relerr_real_6_37_rank2
    subroutine check_relerr_real_6_37_rank2( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_check() ) return
        call assert_relerr_real_6_37_rank2( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_relerr_real_6_37_rank2
    subroutine unittest_relerr_real_6_37_rank2( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(6,37)), dimension(:,:), intent(in) :: a,b
        real(kind=selected_real_kind(6,37)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_relerr_real_6_37_rank2( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_relerr_real_6_37_rank2
    subroutine assert_relerr_real_15_307_rank0( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), allocatable :: a_str, b_str, e_str
#else
        character(:), allocatable :: a_str, b_str, e_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        real(kind=selected_real_kind(15,307)) :: e
        character(len=40) :: epsrel_str
        
        type(unittest_error_rank0) :: info
        
        e = relerr(a,b)
        if( e <= epsrel ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES22.15"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str,stat=stat)
#else
            allocate(a_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str, lfmt_width=", &
                lfmt_width, " (assert_relerr_real_15_307_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str,stat=stat)
#else
            allocate(b_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str, lfmt_width=", &
                lfmt_width, " (assert_relerr_real_15_307_rank0)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(e_str,stat=stat)
#else
            allocate(e_str,source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "e_str, lfmt_width=", &
                lfmt_width, " (assert_relerr_real_15_307_rank0)"
            
            write(unit=a_str,fmt=lfmt) a
            write(unit=b_str,fmt=lfmt) b
            write(unit=e_str,fmt=lfmt) e
            
            write(unit=epsrel_str,fmt="(ES8.1)") epsrel
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( e <= epsrel )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank0_diff = .not. ( e <= epsrel )
            unittest_error_rank0_a = a_str
            unittest_error_rank0_b = b_str
            
            unittest_error_rank0_extra = ""
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, &
                    "|(" // trim(info%a_name) // "-" // trim(info%b_name) // ")/" // trim(info%a_name) // "| <= " // epsrel_str )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%extra = e_str
#else
            unittest_error_rank0_extra = e_str
#endif
            info%extra_name = "relerr"
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_relerr_real_15_307_rank0
    subroutine precondition_relerr_real_15_307_rank0( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_precondition() ) return
        call assert_relerr_real_15_307_rank0( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_relerr_real_15_307_rank0
    subroutine postcondition_relerr_real_15_307_rank0( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_postcondition() ) return
        call assert_relerr_real_15_307_rank0( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_relerr_real_15_307_rank0
    subroutine check_relerr_real_15_307_rank0( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_check() ) return
        call assert_relerr_real_15_307_rank0( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_relerr_real_15_307_rank0
    subroutine unittest_relerr_real_15_307_rank0( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_relerr_real_15_307_rank0( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_relerr_real_15_307_rank0
    subroutine assert_relerr_real_15_307_rank1( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:), allocatable :: a_str, b_str, e_str
#else
        character(:), dimension(:), allocatable :: a_str, b_str, e_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        real(kind=selected_real_kind(15,307)), dimension(size(a,1)) :: e
        character(len=40) :: epsrel_str
        
        integer :: i1
        type(unittest_error_rank1) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        e = relerr(a,b)
        if( all( e <= epsrel ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES22.15"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1)),stat=stat)
#else
            allocate(a_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_relerr_real_15_307_rank1)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1)),stat=stat)
#else
            allocate(b_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_relerr_real_15_307_rank1)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(e_str(size(a,1)),stat=stat)
#else
            allocate(e_str(size(a,1)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "e_str(",size(a,1),"), lfmt_width=", &
                lfmt_width, " (assert_relerr_real_15_307_rank1)"
            
            do i1=1,size(a,1)
                write(unit=a_str(i1),fmt=lfmt) a(i1)
                write(unit=b_str(i1),fmt=lfmt) b(i1)
                write(unit=e_str(i1),fmt=lfmt) e(i1)
            end do
            
            write(unit=epsrel_str,fmt="(ES8.1)") epsrel
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( e <= epsrel )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank1_diff = .not. ( e <= epsrel )
            unittest_error_rank1_a = a_str
            unittest_error_rank1_b = b_str
            
            if( allocated(unittest_error_rank1_extra) ) &
                deallocate(unittest_error_rank1_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, &
                    "|(" // trim(info%a_name) // "-" // trim(info%b_name) // ")/" // trim(info%a_name) // "| <= " // epsrel_str )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%extra = e_str
#else
            unittest_error_rank1_extra = e_str
#endif
            info%extra_name = "relerr"
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_relerr_real_15_307_rank1
    subroutine precondition_relerr_real_15_307_rank1( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_precondition() ) return
        call assert_relerr_real_15_307_rank1( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_relerr_real_15_307_rank1
    subroutine postcondition_relerr_real_15_307_rank1( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_postcondition() ) return
        call assert_relerr_real_15_307_rank1( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_relerr_real_15_307_rank1
    subroutine check_relerr_real_15_307_rank1( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_check() ) return
        call assert_relerr_real_15_307_rank1( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_relerr_real_15_307_rank1
    subroutine unittest_relerr_real_15_307_rank1( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_relerr_real_15_307_rank1( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_relerr_real_15_307_rank1
    subroutine assert_relerr_real_15_307_rank2( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        
        ! Local variables
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
        character(MAX_CHARACTER_LEN), dimension(:,:), allocatable :: a_str, b_str, e_str
#else
        character(:), dimension(:,:), allocatable :: a_str, b_str, e_str
#endif
        character(len=40) :: lfmt
        integer :: lfmt_width, stat
        real(kind=selected_real_kind(15,307)), dimension(size(a,1),size(a,2)) :: e
        character(len=40) :: epsrel_str
        
        integer :: i1,i2
        type(unittest_error_rank2) :: info
        
        ! Ensure the correct array sizes TODO: precondition
        if( .not. assert_array_shape( shape(a),shape(b), &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) ) return
        
        e = relerr(a,b)
        if( all( e <= epsrel ) ) then
            ! NOP
        else
            ! Export the data as character string
            lfmt = "("//trim(optional_character(fmt,"ES22.15"))//")"
            lfmt_width = fmt_width( lfmt )
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(a_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(a_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "a_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_relerr_real_15_307_rank2)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(b_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(b_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "b_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_relerr_real_15_307_rank2)"
#ifdef FC_FIXED_LENGTH_CHARACTERSTRINGS
            allocate(e_str(size(a,1),size(a,2)),stat=stat)
#else
            allocate(e_str(size(a,1),size(a,2)),source=repeat(" ",lfmt_width),stat=stat)
#endif
            if( stat /= 0 ) print *, "*** Internal error: could not allocate ", &
                "e_str(",size(a,1),size(a,2),"), lfmt_width=", &
                lfmt_width, " (assert_relerr_real_15_307_rank2)"
            
            do i1=1,size(a,1)
            do i2=1,size(a,2)
                write(unit=a_str(i1,i2),fmt=lfmt) a(i1,i2)
                write(unit=b_str(i1,i2),fmt=lfmt) b(i1,i2)
                write(unit=e_str(i1,i2),fmt=lfmt) e(i1,i2)
            end do
            end do
            
            write(unit=epsrel_str,fmt="(ES8.1)") epsrel
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%diff = .not. ( e <= epsrel )
            info%a = a_str
            info%b = b_str
#else
            unittest_error_rank2_diff = .not. ( e <= epsrel )
            unittest_error_rank2_a = a_str
            unittest_error_rank2_b = b_str
            
            if( allocated(unittest_error_rank2_extra) ) &
                deallocate(unittest_error_rank2_extra)
            
#endif
            
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            info%statement = optional_character( statement, &
                    "|(" // trim(info%a_name) // "-" // trim(info%b_name) // ")/" // trim(info%a_name) // "| <= " // epsrel_str )
            
            ! TODO: check class invariants info
            
            ! Populate additional information
            info%show_difference_marks = .true.
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            info%extra = e_str
#else
            unittest_error_rank2_extra = e_str
#endif
            info%extra_name = "relerr"
            
            ! Create the error and report failed
            if( present(reason) ) then
                call create_error( ifail, info, reason=reason )
            else
                call create_error( ifail, info )
            end if
        end if
    end subroutine assert_relerr_real_15_307_rank2
    subroutine precondition_relerr_real_15_307_rank2( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_precondition() ) return
        call assert_relerr_real_15_307_rank2( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine precondition_relerr_real_15_307_rank2
    subroutine postcondition_relerr_real_15_307_rank2( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_postcondition() ) return
        call assert_relerr_real_15_307_rank2( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine postcondition_relerr_real_15_307_rank2
    subroutine check_relerr_real_15_307_rank2( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        if( skip_check() ) return
        call assert_relerr_real_15_307_rank2( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
    end subroutine check_relerr_real_15_307_rank2
    subroutine unittest_relerr_real_15_307_rank2( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        real(kind=selected_real_kind(15,307)), dimension(:,:), intent(in) :: a,b
        real(kind=selected_real_kind(15,307)), intent(in) :: epsrel
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        type(error) :: local_ifail
        if( skip_unittest() ) return
        associate( ifail=>local_ifail )
            call assert_relerr_real_15_307_rank2( a, b, epsrel, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason )
        end associate
        call handle_unittest( local_ifail, ifail )
    end subroutine unittest_relerr_real_15_307_rank2


    !--------------------------------------------------------------------------
    ! Miscellaneous
    !--------------------------------------------------------------------------
    
    recursive function assert_array_shape( shape_a,shape_b, &
                            comment, ifail, statement,a_name,b_name,filename,line,fmt,reason ) result( equal_shape )
        integer, dimension(:), intent(in) :: shape_a, shape_b
        
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment, statement, fmt
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail
        type(error), intent(in out), optional :: reason
        logical :: equal_shape
        
        equal_shape = .false. 
        if( size(shape_a) /= size(shape_b) ) then
            call assert_eq( size(shape_a), size(shape_b), statement=statement, & 
                    a_name=a_name, b_name=b_name, filename=filename, line=line, &
                    comment=optional_character(comment,"") // "ranks differ", ifail=ifail, fmt=fmt )
            return
        end if
        if( any(shape_a /= shape_b) ) then
            ! Cannot cause infinite recursion because the arrays have the same size
            call assert_eq( shape_a, shape_b, statement=statement, & 
                    a_name="shape(" // trim(optional_character(a_name,"a")) // ")", &
                    b_name="shape(" // trim(optional_character(b_name,"b")) // ")", filename=filename, line=line, &
                    comment=trim(optional_character(comment)) // " sizes differ", ifail=ifail, fmt=fmt, reason=reason )
            return
        end if
        equal_shape = .true.
        
    end function assert_array_shape
    
    function optional_logical( a, default )
        logical, intent(in), optional :: a
        logical, intent(in) :: default
        logical :: optional_logical
        if( present(a) ) then
            optional_logical = a
        else
            optional_logical = default
        end if
    end function optional_logical
    function optional_integer( a, default )
        integer, intent(in), optional :: a
        integer, intent(in) :: default
        integer :: optional_integer
        if( present(a) ) then
            optional_integer = a
        else
            optional_integer = default
        end if
    end function optional_integer
    function optional_character( a, default ) result( name )
        character(len=*), intent(in), optional :: a, default
        character(:), allocatable :: name
        name = optional_allocatable_character( a, default=default )
        
    end function optional_character
    function optional_allocatable_character( a, b, default ) result( name )
        character(len=*), intent(in), optional :: a, default
#ifndef FC_NO_ALLOCATABLE_DTCOMP
        character(:), allocatable, intent(in), optional :: b
#else
        character(len=*), intent(in), optional :: b
#endif
        character(len=40) :: name
        
        name = ""
        if( present(default) ) then
            name = default
        end if
        if( present(b) ) then
#ifndef FC_NO_ALLOCATABLE_DTCOMP
            if( allocated(b) ) then
                name = b
            end if
#else
            if( len_trim(b) > 0 ) then
                name = b
            end if
#endif
        end if
        if( present(a) ) then
            if( len_trim(a) > 0 ) then
                name = a
            end if
        end if
        
    end function optional_allocatable_character
    
    pure function fmt_width( fmt ) result( width )
        character(len=*), intent(in) :: fmt
        integer :: width
        
        integer :: start_width, end_width
        
        start_width = scan(fmt,"FILESAN",back=.true.) + 1
        end_width = scan(fmt,".)") - 1
        if( end_width < 0 ) end_width = len_trim(fmt)
        
        read(unit=fmt(start_width:end_width),fmt=*) width
    end function fmt_width

end module error_handling_unittest