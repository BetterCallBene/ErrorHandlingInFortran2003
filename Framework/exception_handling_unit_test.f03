! EXCEPTION_HANDLING_UNIT_TEST
! 
!   Collection of wrapper arround commonly used routines that need to check 
!   some condition.
! 
! HISTORY
! 
!   20110217 KP - Initial version
!   20110412 KP - Ported to autogenerated system
!   20110421 (KP) - Re-generated
! 
! AUTHOR
! 
!   Koen Poppe, Department of Computer Science,
!   Katholieke Universiteit Leuven, Celestijnenlaan 200A,
!   B-3001 Heverlee, Belgium
!   Email:	Koen.Poppe@cs.kuleuven.be
!
module exception_handling_unit_test
    use exception_handling_exception
    use design_by_contract
    implicit none
    private
    save


    ! Primitives
    public :: assert
    interface assert
    	module procedure assert_logical
    end interface assert
    public :: assert_fail
    public :: assert_success

    ! Unit testing
    integer, public :: OUTPUT_WIDTH = 80 ! Maximal width of the output
    character(len=5), parameter :: indent = ""
    integer :: ntest = -1, nfail = -1
    character(len=32) :: module_name

    public :: unit_test_reset
    public :: unit_test_results
    public :: write_unit_test_report
    
    ! Reports and exception types
    ! 20110413 KP - Should become obsolete
    private :: assert_report
    interface assert_report
        module procedure assert_rank0_report
        module procedure assert_rank1_report
        module procedure assert_rank2_report
    end interface

    type, extends(dbc_exception), public :: unit_test_exception
        character(:), allocatable :: a_name,b_name,filename
        integer :: line = -1
    end type unit_test_exception


    type, extends(unit_test_exception) :: unit_test_exception_rank0
        logical :: diff
        character(:), allocatable :: a,b
    contains
        procedure :: info_message => unit_test_exception_info_message_rank0
    end type unit_test_exception_rank0
    type, extends(unit_test_exception) :: unit_test_exception_rank1
        logical, dimension(:), allocatable :: diff
        character(:), dimension(:), allocatable :: a,b
    contains
        procedure :: info_message => unit_test_exception_info_message_rank1
    end type unit_test_exception_rank1
    type, extends(unit_test_exception) :: unit_test_exception_rank2
        logical, dimension(:,:), allocatable :: diff
        character(:), dimension(:,:), allocatable :: a,b
    contains
        procedure :: info_message => unit_test_exception_info_message_rank2
    end type unit_test_exception_rank2

    ! Automatic generated

    public :: assert_equal
    interface assert_equal
        module procedure assert_equal_logical_rank0
        module procedure assert_equal_logical_rank1
        module procedure assert_equal_logical_rank2
        module procedure assert_equal_integer_rank0
        module procedure assert_equal_integer_rank1
        module procedure assert_equal_integer_rank2
    end interface
    
    public :: abserr
    interface abserr
        module procedure abserr_real_rank0
        module procedure abserr_real_rank1
        module procedure abserr_real_rank2
        module procedure abserr_real_double_rank0
        module procedure abserr_real_double_rank1
        module procedure abserr_real_double_rank2
    end interface
    
    public :: assert_abserr
    interface assert_abserr
        module procedure assert_abserr_real_rank0
        module procedure assert_abserr_real_rank1
        module procedure assert_abserr_real_rank2
        module procedure assert_abserr_real_double_rank0
        module procedure assert_abserr_real_double_rank1
        module procedure assert_abserr_real_double_rank2
    end interface
    
    public :: relerr
    interface relerr
        module procedure relerr_real_rank0
        module procedure relerr_real_rank1
        module procedure relerr_real_rank2
        module procedure relerr_real_double_rank0
        module procedure relerr_real_double_rank1
        module procedure relerr_real_double_rank2
    end interface
    
    public :: assert_relerr
    interface assert_relerr
        module procedure assert_relerr_real_rank0
        module procedure assert_relerr_real_rank1
        module procedure assert_relerr_real_rank2
        module procedure assert_relerr_real_double_rank0
        module procedure assert_relerr_real_double_rank1
        module procedure assert_relerr_real_double_rank2
    end interface
    
contains

    !--------------------------------------------------------------------------
    ! Primitives
    !--------------------------------------------------------------------------

    ! Test if the <expression> evaluates to .true. If not, a warning is
    ! issued with the <statement> and, optionally, the <comment> argument.
    ! The preprocessor macros also supply the <filename> and <line>.
    !
    ! The test report is updated accordingly.
    !
    subroutine assert_logical( expression, a_name,b_name,filename,line,comment, ifail )

        logical, intent(in) :: expression
        
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail

        if( ntest >= 0 ) then
            ntest = ntest + 1
        end if
        if( expression ) then
            ! nothing to do, it worked
        else
            write(unit=*,fmt="(A)") "***"
            if( len_trim(module_name) > 0 ) then
                write(unit=*,fmt="(3A)") " ", trim(module_name), ", "
            end if
        
            if( nfail >= 0 ) then
                nfail = nfail + 1
                write(unit=*,fmt="(A,I4)",advance="no") &
                    "Test", ntest
            else
                 write(unit=*,fmt="(A)",advance="no") &
                    "Run-time check: "
            end if
        
            if( present(line) ) then
                write(unit=*,fmt="(A,I4)",advance="no") "@",line
            else
                write(unit=*,fmt="(A5)",advance="no") ""
            end if

            write(unit=*,fmt="(2A)",advance="no") ": ", " trim( statement )"

            if( present(comment) ) then
                write(unit=*,fmt="(3A)") ": ", trim(comment), "; failed..."
            else
                write(unit=*,fmt="(A)") " failed..."
            end if
        end if

    end subroutine assert_logical

    subroutine assert_fail( a_name,b_name,filename,line,comment, ifail )
        
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail
        call assert_logical( .false., a_name,b_name,filename,line,comment, ifail )
    end subroutine assert_fail

    subroutine assert_success( a_name,b_name,filename,line,comment, ifail )
        
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail
        call assert_logical( .true., a_name,b_name,filename,line,comment, ifail )
    end subroutine assert_success

    !--------------------------------------------------------------------------
    ! Unit testing
    !--------------------------------------------------------------------------

    ! Reset the test results
    subroutine unit_test_reset(name)
        character(len=*),intent(in), optional :: name
        ntest = 0
        nfail = 0
        module_name = ""
        if( present(name) ) then
            module_name = name
        end if
    end subroutine unit_test_reset

    ! Returns the results of the test so far.
    subroutine unit_test_results(nb_passed,nb_failed,nb_tests)
        integer, intent( out ), optional :: nb_passed, nb_failed, nb_tests
        if( present( nb_passed ) ) nb_passed = ntest-nfail
        if( present( nb_failed ) ) nb_failed = nfail
        if( present( nb_tests  ) ) nb_tests     = ntest
    end subroutine unit_test_results

    ! Write the test report in a fashion compatible to the test warnings.
    subroutine write_unit_test_report()
        integer :: nb_failed, nb_tests
        call unit_test_results(nb_failed=nb_failed, nb_tests=nb_tests)
        if( nb_failed == 0 ) then
            write(unit=*,fmt="(A,I3,2A)") "     [OK] ", nb_tests, " tests passed. ", trim(module_name)
        else
            write(unit=*,fmt="(A,I3,2A)") &
                "  [??] ", nb_failed, " tests FAILED. ", trim(module_name)
        end if
    end subroutine write_unit_test_report

    !--------------------------------------------------------------------------
    ! Reporting
    !--------------------------------------------------------------------------

    subroutine assert_rank0_report( diff, a,b, a_name,b_name,filename,line,comment, ifail, extra,extra_name )
        logical, intent(in) :: diff
        character(len=*), intent(in) :: a,b
        character(len=*), intent(in), optional :: extra
        character(len=*), intent(in), optional :: extra_name
        
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail

        call assert_fail( a_name,b_name,filename,line,comment, ifail )
        write(unit=*,fmt="(2(A,I0),A)") " [??] elements differ"

    end subroutine assert_rank0_report

    subroutine assert_rank1_report( diff, a,b, a_name,b_name,filename,line,comment, ifail, extra,extra_name, idx_row, recursion )
        logical, dimension(:), intent(in) :: diff
        character(len=*), dimension(:), intent(in) :: a,b
        character(len=*), dimension(:), intent(in), optional :: extra
        character(len=*), intent(in), optional :: extra_name
        character(len=*), dimension(:), intent(in), optional :: idx_row
        logical, intent(in), optional :: recursion
        
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail
    
        integer, dimension(:), allocatable :: diff_idx
        integer :: i,j, w, nb, nb_diff, max_row, row, idx, name_width
        character(len=40) :: fmt_str, la_name, lb_name, trailing
        character(len=3), parameter :: eqs = " = ", sep = " | ", blk = "   "
        character(len=len(blk)) :: sep_or_blk
        character(len=len(a(1))), dimension(size(a)) :: diff_str, the_row
    
        la_name = optional_name(a_name,"a")
        lb_name = optional_name(b_name,"b")
        name_width = max(len_trim(la_name),len_trim(lb_name))
        if( present(extra_name) ) then
            name_width = max(name_width,len_trim(extra_name))
        end if
    
        w = len(a(1))
        nb = size(diff)
        nb_diff = count(diff)
        allocate(diff_idx(nb_diff))
        diff_idx = pack( (/ (i,i=1,nb) /), diff )
    
        diff_str = " "
        do i=1,nb_diff
            idx = diff_idx(i)
            do j=1,len(a(idx))
                if( a(idx)(j:j) /= b(idx)(j:j) ) then
                    diff_str(idx)(j:j) = "^"
                else
                    diff_str(idx)(j:j) = "-"
                end if
            end do
        end do
    
        if( .not. optional_logical( recursion,.false. ) ) then
            call assert_fail( a_name,b_name,filename,line,comment, ifail )
            write(unit=*,fmt="(2(A,I0),A)") " [??] ", nb_diff, " of ", nb, " elements differ: "
        end if

        max_row = (OUTPUT_WIDTH-name_width)/(w+len(sep))
        if( optional_logical( recursion,.false.) .or. (nb <= max_row .and. .not. present(idx_row)) ) then
            if( nb > max_row ) then
                nb = max_row
                write(unit=trailing,fmt="(2A)") sep, "..."
            else
                trailing = ""
            end if
        
            if( nb == 1 ) then
                write(unit=fmt_str,fmt="(2(A,I0),A)") "(A",name_width,",A,A",w,",A)"
            else
                write(unit=fmt_str,fmt="(2(A,I0),A,I0,3A,I0,A)") "(A",name_width,",A,A",w,",",nb-1,"('", sep, "',A",w,"),A)"
            end if
            write(unit=*,fmt=fmt_str) trim(la_name), eqs, a(1:nb), trim(trailing)
            write(unit=*,fmt=fmt_str) trim(lb_name), eqs, b(1:nb), trim(trailing)

            if( nb == 1 ) then
                write(unit=fmt_str,fmt="(2(A,I0),A)") "(A",name_width+len(eqs),",A",w,",A)"
            else
                write(unit=fmt_str,fmt="(2(A,I0),A,I0,3A,I0,A)") "(A",name_width+len(eqs),",A",w,",",nb-1,"('", blk, "',A",w,"),A)"
            end if
            write(unit=*,fmt=fmt_str) "", diff_str(1:nb), trim(trailing)
        
            if( present(extra) ) then
                if( nb == 1 ) then
                    write(unit=fmt_str,fmt="(2(A,I0),A)") "(A",name_width,",A,A",w,",A)"
                else
                    write(unit=fmt_str,fmt="(2(A,I0),A,I0,3A,I0,A)") "(A",name_width,",A,A",w,",",nb-1,"('", sep, "',A",w,"),A)"
                end if
                if( present(extra_name) ) then
                    write(unit=*,fmt=fmt_str) extra_name, eqs, extra(1:nb), trim(trailing)
                else
                    write(unit=*,fmt=fmt_str) "", eqs, extra(1:nb), trim(trailing)
                end if
            end if
            return
        end if
    
        max_row = (OUTPUT_WIDTH-name_width-len(eqs))/(w+len(sep))
        print *, "max_row = ", max_row
        do row=0,4
            write(unit=fmt_str,fmt="(2(A,I0),A)") "(A",name_width,",A",len(eqs),")"
            sep_or_blk = sep
            select case( row )
                case( 0 ) ! Indexes
                    write(unit=*,fmt=fmt_str,advance="no") "idx", eqs
                    if( present( idx_row ) ) then
                        the_row = idx_row
                    else
                        the_row = " "
                        write(unit=fmt_str,fmt="(A,I0,A)") "(I", len(a(1)), ")"
                        do i=1,nb_diff
                            write(unit=the_row(diff_idx(i)),fmt=fmt_str) diff_idx(i)
                        end do
                    end if
                case( 1 )
                    write(unit=*,fmt=fmt_str,advance="no") trim(la_name), eqs
                    the_row = a
                case( 2 )
                    write(unit=*,fmt=fmt_str,advance="no") trim(lb_name), eqs
                    the_row = b
                case( 3 )
                    write(unit=*,fmt=fmt_str,advance="no") "",""
                    the_row = diff_str
                    sep_or_blk = blk
                case( 4 )
                    if( present(extra) ) then
                        if( present(extra_name) ) then
                            write(unit=*,fmt=fmt_str,advance="no") trim(extra_name), eqs
                        else
                            write(unit=*,fmt=fmt_str,advance="no") "", ""
                        end if
                        the_row = extra
                    else
                        exit
                    end if
            end select
        
            idx = 0
            do i=1,min(nb_diff,max_row)
                if( i>1 ) then
                    write(unit=*,fmt="(A)",advance="no") sep_or_blk
                end if
            
                ! Elements in between?
                if( diff_idx(i) > idx+1 ) then
                    write(unit=*,fmt="(2A)",advance="no") ".", sep_or_blk
                end if
            
                ! Element
                idx = diff_idx(i)
                write(unit=*,fmt="(A)",advance="no") the_row(idx)
            end do
            if( nb_diff > max_row ) then
                write(unit=*,fmt="(2A)") sep_or_blk, "..."
            else
                write(unit=*,fmt=*) ! New line
            end if
        end do
    
    end subroutine assert_rank1_report

    subroutine assert_rank2_report( diff, a,b, a_name,b_name,filename,line,comment, ifail, extra,extra_name, idx_row, recursion )
        logical, dimension(:,:), intent(in) :: diff
        character(len=*), dimension(:,:), intent(in) :: a,b
        character(len=*), dimension(:,:), intent(in), optional :: extra
        character(len=*), intent(in), optional :: extra_name
        character(len=*), dimension(:), intent(in), optional :: idx_row
        logical, intent(in), optional :: recursion
        
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail
    
        character(len=40) :: a_rowstr, b_rowstr, fmt_str
        integer :: row
    
        if( .not. optional_logical( recursion,.false. ) ) then
            call assert_fail( a_name,b_name,filename,line,comment, ifail )
            write(unit=*,fmt="(2(A,I0),A)") " [??] ", count(diff), " of ", size(diff), " elements differ: "
        end if
    
        do row=1,size(a,1)
            write(unit=*,fmt="(A,100L2)") indent, .not. diff(row,:)
        end do
    
        write(unit=fmt_str,fmt="(A,I0,A)") "(2A,I",ceiling(log10(real(size(a,1)))),",A)"
        do row=1,size(a,1)
            if( any(diff(row,:)) ) then
                write(unit=a_rowstr,fmt=fmt_str) optional_name(a_name,"a"), "(", row, ",:)"
                write(unit=b_rowstr,fmt=fmt_str) optional_name(b_name,"b"), "(", row, ",:)"
                if( present(extra) ) then
                    if( present(extra_name) ) then
                        call assert_report( diff(row,:), a(row,:),b(row,:), a_rowstr,b_rowstr, filename,line,comment, &
                                recursion=.true., extra=extra(row,:), extra_name=extra_name )
                    else
                        call assert_report( diff(row,:), a(row,:),b(row,:), a_rowstr,b_rowstr, filename,line,comment, &
                                recursion=.true., extra=extra(row,:) )
                    end if
                    if( row < size(a,1) ) then
                        write(unit=*,fmt="(A)") repeat("-",len_trim(a_rowstr))
                    end if
                else
                    call assert_report( diff(row,:), a(row,:),b(row,:), a_rowstr,b_rowstr, filename,line,comment, &
                        recursion=.true. )
                end if
            end if
        end do
        write(unit=*,fmt=*) "" ! new line
    
    end subroutine assert_rank2_report

    ! Type bound procedures

    subroutine unit_test_exception_info_message_rank0( info, message )
        class(unit_test_exception_rank0), intent(in) :: info
        character(len=*), intent(out) :: message
        message = "TODO: add message here instead of outputting it straight away ..."
        call assert_rank0_report( info%diff, info%a, info%b, &
                info%a_name,info%b_name,info%filename,info%line ) ! TODO: other arguments?
    end subroutine unit_test_exception_info_message_rank0
    subroutine unit_test_exception_info_message_rank1( info, message )
        class(unit_test_exception_rank1), intent(in) :: info
        character(len=*), intent(out) :: message
        message = "TODO: add message here instead of outputting it straight away ..."
        call assert_rank1_report( info%diff, info%a, info%b, &
                info%a_name,info%b_name,info%filename,info%line ) ! TODO: other arguments?
    end subroutine unit_test_exception_info_message_rank1
    subroutine unit_test_exception_info_message_rank2( info, message )
        class(unit_test_exception_rank2), intent(in) :: info
        character(len=*), intent(out) :: message
        message = "TODO: add message here instead of outputting it straight away ..."
        call assert_rank2_report( info%diff, info%a, info%b, &
                info%a_name,info%b_name,info%filename,info%line ) ! TODO: other arguments?
    end subroutine unit_test_exception_info_message_rank2
    
    !--------------------------------------------------------------------------
    ! assert_equal
    !--------------------------------------------------------------------------
    
	subroutine assert_equal_logical_rank0( a, b, a_name,b_name,filename,line,comment, ifail )
		logical, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail
		character(len=1) :: a_str, b_str
		type(unit_test_exception_rank0) :: info

		
		if( a .eqv. b ) then
			call assert_success( a_name,b_name,filename,line,comment, ifail )
		else
			write(unit=a_str,fmt="(L1)") a
			write(unit=b_str,fmt="(L1)") b
			! Populate exception_info type
			info%a_name = optional_name( a_name, "" )
			info%b_name = optional_name( b_name, "" )
			info%filename = optional_name( filename, "" )
			if( present(line) ) then
			    info%line = line
			else
			    info%line = -1
			end if

			info%diff = .not. ( a .eqv. b )
			info%a = a_str
			info%b = b_str
	
			call create_exception( ifail, info )
!			call assert_report( .not. ( a .eqv. b ), a_str, b_str, a_name,b_name,filename,line,comment, ifail )
		end if
	end subroutine assert_equal_logical_rank0
	subroutine assert_equal_logical_rank1( a, b, a_name,b_name,filename,line,comment, ifail )
		logical, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail
		character(len=1), dimension(size(a,1)) :: a_str, b_str
		integer :: i1
		type(unit_test_exception_rank1) :: info

		
		if( .not. assert_array_shape( shape(a),shape(b), a_name,b_name,filename,line,comment, ifail ) ) then
			return
		end if
		if( all( a .eqv. b ) ) then
			call assert_success( a_name,b_name,filename,line,comment, ifail )
		else
			do i1=1,size(a,1)
				write(unit=a_str(i1),fmt="(L1)") a(i1)
				write(unit=b_str(i1),fmt="(L1)") b(i1)
			end do
			! Populate exception_info type
			info%a_name = optional_name( a_name, "" )
			info%b_name = optional_name( b_name, "" )
			info%filename = optional_name( filename, "" )
			if( present(line) ) then
			    info%line = line
			else
			    info%line = -1
			end if

			info%diff = .not. ( a .eqv. b )
			info%a = a_str
			info%b = b_str
	
			call create_exception( ifail, info )
!			call assert_report( .not. ( a .eqv. b ), a_str, b_str, a_name,b_name,filename,line,comment, ifail )
		end if
	end subroutine assert_equal_logical_rank1
	subroutine assert_equal_logical_rank2( a, b, a_name,b_name,filename,line,comment, ifail )
		logical, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail
		character(len=1), dimension(size(a,1),size(a,2)) :: a_str, b_str
		integer :: i1,i2
		type(unit_test_exception_rank2) :: info

		
		if( .not. assert_array_shape( shape(a),shape(b), a_name,b_name,filename,line,comment, ifail ) ) then
			return
		end if
		if( all( a .eqv. b ) ) then
			call assert_success( a_name,b_name,filename,line,comment, ifail )
		else
			do i1=1,size(a,1)
			do i2=1,size(a,2)
				write(unit=a_str(i1,i2),fmt="(L1)") a(i1,i2)
				write(unit=b_str(i1,i2),fmt="(L1)") b(i1,i2)
			end do
			end do
			! Populate exception_info type
			info%a_name = optional_name( a_name, "" )
			info%b_name = optional_name( b_name, "" )
			info%filename = optional_name( filename, "" )
			if( present(line) ) then
			    info%line = line
			else
			    info%line = -1
			end if

			info%diff = .not. ( a .eqv. b )
			info%a = a_str
			info%b = b_str
	
			call create_exception( ifail, info )
!			call assert_report( .not. ( a .eqv. b ), a_str, b_str, a_name,b_name,filename,line,comment, ifail )
		end if
	end subroutine assert_equal_logical_rank2
	subroutine assert_equal_integer_rank0( a, b, a_name,b_name,filename,line,comment, ifail )
		integer, intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail
		character(len=8) :: a_str, b_str
		type(unit_test_exception_rank0) :: info

		
		if( a == b ) then
			call assert_success( a_name,b_name,filename,line,comment, ifail )
		else
			write(unit=a_str,fmt="(I8)") a
			write(unit=b_str,fmt="(I8)") b
			! Populate exception_info type
			info%a_name = optional_name( a_name, "" )
			info%b_name = optional_name( b_name, "" )
			info%filename = optional_name( filename, "" )
			if( present(line) ) then
			    info%line = line
			else
			    info%line = -1
			end if

			info%diff = .not. ( a == b )
			info%a = a_str
			info%b = b_str
	
			call create_exception( ifail, info )
!			call assert_report( .not. ( a == b ), a_str, b_str, a_name,b_name,filename,line,comment, ifail )
		end if
	end subroutine assert_equal_integer_rank0
	subroutine assert_equal_integer_rank1( a, b, a_name,b_name,filename,line,comment, ifail )
		integer, dimension(:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail
		character(len=8), dimension(size(a,1)) :: a_str, b_str
		integer :: i1
		type(unit_test_exception_rank1) :: info

		
		if( .not. assert_array_shape( shape(a),shape(b), a_name,b_name,filename,line,comment, ifail ) ) then
			return
		end if
		if( all( a == b ) ) then
			call assert_success( a_name,b_name,filename,line,comment, ifail )
		else
			do i1=1,size(a,1)
				write(unit=a_str(i1),fmt="(I8)") a(i1)
				write(unit=b_str(i1),fmt="(I8)") b(i1)
			end do
			! Populate exception_info type
			info%a_name = optional_name( a_name, "" )
			info%b_name = optional_name( b_name, "" )
			info%filename = optional_name( filename, "" )
			if( present(line) ) then
			    info%line = line
			else
			    info%line = -1
			end if

			info%diff = .not. ( a == b )
			info%a = a_str
			info%b = b_str
	
			call create_exception( ifail, info )
!			call assert_report( .not. ( a == b ), a_str, b_str, a_name,b_name,filename,line,comment, ifail )
		end if
	end subroutine assert_equal_integer_rank1
	subroutine assert_equal_integer_rank2( a, b, a_name,b_name,filename,line,comment, ifail )
		integer, dimension(:,:), intent(in) :: a,b
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail
		character(len=8), dimension(size(a,1),size(a,2)) :: a_str, b_str
		integer :: i1,i2
		type(unit_test_exception_rank2) :: info

		
		if( .not. assert_array_shape( shape(a),shape(b), a_name,b_name,filename,line,comment, ifail ) ) then
			return
		end if
		if( all( a == b ) ) then
			call assert_success( a_name,b_name,filename,line,comment, ifail )
		else
			do i1=1,size(a,1)
			do i2=1,size(a,2)
				write(unit=a_str(i1,i2),fmt="(I8)") a(i1,i2)
				write(unit=b_str(i1,i2),fmt="(I8)") b(i1,i2)
			end do
			end do
			! Populate exception_info type
			info%a_name = optional_name( a_name, "" )
			info%b_name = optional_name( b_name, "" )
			info%filename = optional_name( filename, "" )
			if( present(line) ) then
			    info%line = line
			else
			    info%line = -1
			end if

			info%diff = .not. ( a == b )
			info%a = a_str
			info%b = b_str
	
			call create_exception( ifail, info )
!			call assert_report( .not. ( a == b ), a_str, b_str, a_name,b_name,filename,line,comment, ifail )
		end if
	end subroutine assert_equal_integer_rank2
    
    !--------------------------------------------------------------------------
    ! abserr
    ! 
    ! These functions never cause floating point exceptions (i.e., inf-inf)
    !--------------------------------------------------------------------------
    
	function abserr_real_rank0( a,b ) result( abs_err )
		real, intent(in) :: a
		real, intent(in) :: b
		real :: abs_err
        if( a/=b ) then
            abs_err = abs(a-b)
        else
            abs_err = 0
        end if
			
	end function abserr_real_rank0
	function abserr_real_rank1( a,b ) result( abs_err )
		real, dimension(:), intent(in) :: a
		real, dimension(size(a,1)), intent(in) :: b
		real, dimension(size(a,1)) :: abs_err
        where( a/=b )
            abs_err = abs(a-b)
        elsewhere
            abs_err = 0
        end where
		    
	end function abserr_real_rank1
	function abserr_real_rank2( a,b ) result( abs_err )
		real, dimension(:,:), intent(in) :: a
		real, dimension(size(a,1),size(a,2)), intent(in) :: b
		real, dimension(size(a,1),size(a,2)) :: abs_err
        where( a/=b )
            abs_err = abs(a-b)
        elsewhere
            abs_err = 0
        end where
		    
	end function abserr_real_rank2
	function abserr_real_double_rank0( a,b ) result( abs_err )
		real(kind=kind(1.0d0)), intent(in) :: a
		real(kind=kind(1.0d0)), intent(in) :: b
		real(kind=kind(1.0d0)) :: abs_err
        if( a/=b ) then
            abs_err = abs(a-b)
        else
            abs_err = 0
        end if
			
	end function abserr_real_double_rank0
	function abserr_real_double_rank1( a,b ) result( abs_err )
		real(kind=kind(1.0d0)), dimension(:), intent(in) :: a
		real(kind=kind(1.0d0)), dimension(size(a,1)), intent(in) :: b
		real(kind=kind(1.0d0)), dimension(size(a,1)) :: abs_err
        where( a/=b )
            abs_err = abs(a-b)
        elsewhere
            abs_err = 0
        end where
		    
	end function abserr_real_double_rank1
	function abserr_real_double_rank2( a,b ) result( abs_err )
		real(kind=kind(1.0d0)), dimension(:,:), intent(in) :: a
		real(kind=kind(1.0d0)), dimension(size(a,1),size(a,2)), intent(in) :: b
		real(kind=kind(1.0d0)), dimension(size(a,1),size(a,2)) :: abs_err
        where( a/=b )
            abs_err = abs(a-b)
        elsewhere
            abs_err = 0
        end where
		    
	end function abserr_real_double_rank2
    
    !--------------------------------------------------------------------------
    ! assert_abserr
    !--------------------------------------------------------------------------
    
	subroutine assert_abserr_real_rank0( a, b, epsabs, a_name,b_name,filename,line,comment, ifail )
		real, intent(in) :: a,b
		real, intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail
		character(len=13) :: a_str, b_str, e_str
		real :: e
		e = abserr(a,b)
		if( e <= epsabs ) then
			call assert_success( a_name,b_name,filename,line,comment, ifail )
		else
			write(unit=a_str,fmt="(ES13.5)") a
			write(unit=b_str,fmt="(ES13.5)") b
			write(unit=e_str,fmt="(ES13.5)") e
			call assert_report( e > epsabs, a_str, b_str, a_name,b_name,filename,line,comment, ifail, &
					extra=e_str, extra_name="abserr" )
		end if
	end subroutine assert_abserr_real_rank0
	subroutine assert_abserr_real_rank1( a, b, epsabs, a_name,b_name,filename,line,comment, ifail )
		real, dimension(:), intent(in) :: a,b
		real, intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail
		character(len=13), dimension(size(a,1)) :: a_str, b_str, e_str
		real, dimension(size(a,1)) :: e
		integer :: i1
		if( .not. assert_array_shape( shape(a),shape(b), a_name,b_name,filename,line,comment, ifail ) ) then
			return
		end if
		e = abserr(a,b)
		if( all( e <= epsabs ) ) then
			call assert_success( a_name,b_name,filename,line,comment, ifail )
		else
			do i1=1,size(a,1)
				write(unit=a_str(i1),fmt="(ES13.5)") a(i1)
				write(unit=b_str(i1),fmt="(ES13.5)") b(i1)
				write(unit=e_str(i1),fmt="(ES13.5)") e(i1)
			end do
			call assert_report( e > epsabs, a_str, b_str, a_name,b_name,filename,line,comment, ifail, &
					extra=e_str, extra_name="abserr" )
		end if
	end subroutine assert_abserr_real_rank1
	subroutine assert_abserr_real_rank2( a, b, epsabs, a_name,b_name,filename,line,comment, ifail )
		real, dimension(:,:), intent(in) :: a,b
		real, intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail
		character(len=13), dimension(size(a,1),size(a,2)) :: a_str, b_str, e_str
		real, dimension(size(a,1),size(a,2)) :: e
		integer :: i1,i2
		if( .not. assert_array_shape( shape(a),shape(b), a_name,b_name,filename,line,comment, ifail ) ) then
			return
		end if
		e = abserr(a,b)
		if( all( e <= epsabs ) ) then
			call assert_success( a_name,b_name,filename,line,comment, ifail )
		else
			do i1=1,size(a,1)
			do i2=1,size(a,2)
				write(unit=a_str(i1,i2),fmt="(ES13.5)") a(i1,i2)
				write(unit=b_str(i1,i2),fmt="(ES13.5)") b(i1,i2)
				write(unit=e_str(i1,i2),fmt="(ES13.5)") e(i1,i2)
			end do
			end do
			call assert_report( e > epsabs, a_str, b_str, a_name,b_name,filename,line,comment, ifail, &
					extra=e_str, extra_name="abserr" )
		end if
	end subroutine assert_abserr_real_rank2
	subroutine assert_abserr_real_double_rank0( a, b, epsabs, a_name,b_name,filename,line,comment, ifail )
		real(kind=kind(1.0d0)), intent(in) :: a,b
		real(kind=kind(1.0d0)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail
		character(len=23) :: a_str, b_str, e_str
		real(kind=kind(1.0d0)) :: e
		e = abserr(a,b)
		if( e <= epsabs ) then
			call assert_success( a_name,b_name,filename,line,comment, ifail )
		else
			write(unit=a_str,fmt="(ES23.16)") a
			write(unit=b_str,fmt="(ES23.16)") b
			write(unit=e_str,fmt="(ES23.16)") e
			call assert_report( e > epsabs, a_str, b_str, a_name,b_name,filename,line,comment, ifail, &
					extra=e_str, extra_name="abserr" )
		end if
	end subroutine assert_abserr_real_double_rank0
	subroutine assert_abserr_real_double_rank1( a, b, epsabs, a_name,b_name,filename,line,comment, ifail )
		real(kind=kind(1.0d0)), dimension(:), intent(in) :: a,b
		real(kind=kind(1.0d0)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail
		character(len=23), dimension(size(a,1)) :: a_str, b_str, e_str
		real(kind=kind(1.0d0)), dimension(size(a,1)) :: e
		integer :: i1
		if( .not. assert_array_shape( shape(a),shape(b), a_name,b_name,filename,line,comment, ifail ) ) then
			return
		end if
		e = abserr(a,b)
		if( all( e <= epsabs ) ) then
			call assert_success( a_name,b_name,filename,line,comment, ifail )
		else
			do i1=1,size(a,1)
				write(unit=a_str(i1),fmt="(ES23.16)") a(i1)
				write(unit=b_str(i1),fmt="(ES23.16)") b(i1)
				write(unit=e_str(i1),fmt="(ES23.16)") e(i1)
			end do
			call assert_report( e > epsabs, a_str, b_str, a_name,b_name,filename,line,comment, ifail, &
					extra=e_str, extra_name="abserr" )
		end if
	end subroutine assert_abserr_real_double_rank1
	subroutine assert_abserr_real_double_rank2( a, b, epsabs, a_name,b_name,filename,line,comment, ifail )
		real(kind=kind(1.0d0)), dimension(:,:), intent(in) :: a,b
		real(kind=kind(1.0d0)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail
		character(len=23), dimension(size(a,1),size(a,2)) :: a_str, b_str, e_str
		real(kind=kind(1.0d0)), dimension(size(a,1),size(a,2)) :: e
		integer :: i1,i2
		if( .not. assert_array_shape( shape(a),shape(b), a_name,b_name,filename,line,comment, ifail ) ) then
			return
		end if
		e = abserr(a,b)
		if( all( e <= epsabs ) ) then
			call assert_success( a_name,b_name,filename,line,comment, ifail )
		else
			do i1=1,size(a,1)
			do i2=1,size(a,2)
				write(unit=a_str(i1,i2),fmt="(ES23.16)") a(i1,i2)
				write(unit=b_str(i1,i2),fmt="(ES23.16)") b(i1,i2)
				write(unit=e_str(i1,i2),fmt="(ES23.16)") e(i1,i2)
			end do
			end do
			call assert_report( e > epsabs, a_str, b_str, a_name,b_name,filename,line,comment, ifail, &
					extra=e_str, extra_name="abserr" )
		end if
	end subroutine assert_abserr_real_double_rank2
    
    !--------------------------------------------------------------------------
    ! relerr
    ! 
    ! These functions never cause floating point exceptions (i.e., inf-inf)
    !--------------------------------------------------------------------------
    
	function relerr_real_rank0( a,b ) result( rel_err )
		real, intent(in) :: a
		real, intent(in) :: b
		real :: rel_err
        if( a/=b ) then
            rel_err = abs((a-b)/a)
        else
            rel_err = 0
        end if
			

	end function relerr_real_rank0
	function relerr_real_rank1( a,b ) result( rel_err )
		real, dimension(:), intent(in) :: a
		real, dimension(size(a,1)), intent(in) :: b
		real, dimension(size(a,1)) :: rel_err
        where( a/=b )
            rel_err = abs((a-b)/a)
        elsewhere
            rel_err = 0
        end where
		    

	end function relerr_real_rank1
	function relerr_real_rank2( a,b ) result( rel_err )
		real, dimension(:,:), intent(in) :: a
		real, dimension(size(a,1),size(a,2)), intent(in) :: b
		real, dimension(size(a,1),size(a,2)) :: rel_err
        where( a/=b )
            rel_err = abs((a-b)/a)
        elsewhere
            rel_err = 0
        end where
		    

	end function relerr_real_rank2
	function relerr_real_double_rank0( a,b ) result( rel_err )
		real(kind=kind(1.0d0)), intent(in) :: a
		real(kind=kind(1.0d0)), intent(in) :: b
		real(kind=kind(1.0d0)) :: rel_err
        if( a/=b ) then
            rel_err = abs((a-b)/a)
        else
            rel_err = 0
        end if
			

	end function relerr_real_double_rank0
	function relerr_real_double_rank1( a,b ) result( rel_err )
		real(kind=kind(1.0d0)), dimension(:), intent(in) :: a
		real(kind=kind(1.0d0)), dimension(size(a,1)), intent(in) :: b
		real(kind=kind(1.0d0)), dimension(size(a,1)) :: rel_err
        where( a/=b )
            rel_err = abs((a-b)/a)
        elsewhere
            rel_err = 0
        end where
		    

	end function relerr_real_double_rank1
	function relerr_real_double_rank2( a,b ) result( rel_err )
		real(kind=kind(1.0d0)), dimension(:,:), intent(in) :: a
		real(kind=kind(1.0d0)), dimension(size(a,1),size(a,2)), intent(in) :: b
		real(kind=kind(1.0d0)), dimension(size(a,1),size(a,2)) :: rel_err
        where( a/=b )
            rel_err = abs((a-b)/a)
        elsewhere
            rel_err = 0
        end where
		    

	end function relerr_real_double_rank2
    
    !--------------------------------------------------------------------------
    ! assert_relerr
    !--------------------------------------------------------------------------
    
	subroutine assert_relerr_real_rank0( a, b, epsabs, a_name,b_name,filename,line,comment, ifail )
		real, intent(in) :: a,b
		real, intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail
		character(len=13) :: a_str, b_str, e_str
		real :: e
		e = abserr(a,b)
		if( e <= epsabs ) then
			call assert_success( a_name,b_name,filename,line,comment, ifail )
		else
			write(unit=a_str,fmt="(ES13.5)") a
			write(unit=b_str,fmt="(ES13.5)") b
			write(unit=e_str,fmt="(ES13.5)") e
			call assert_report( e > epsabs, a_str, b_str, a_name,b_name,filename,line,comment, ifail, &
					extra=e_str, extra_name="abserr" )
		end if
	end subroutine assert_relerr_real_rank0
	subroutine assert_relerr_real_rank1( a, b, epsabs, a_name,b_name,filename,line,comment, ifail )
		real, dimension(:), intent(in) :: a,b
		real, intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail
		character(len=13), dimension(size(a,1)) :: a_str, b_str, e_str
		real, dimension(size(a,1)) :: e
		integer :: i1
		if( .not. assert_array_shape( shape(a),shape(b), a_name,b_name,filename,line,comment, ifail ) ) then
			return
		end if
		e = abserr(a,b)
		if( all( e <= epsabs ) ) then
			call assert_success( a_name,b_name,filename,line,comment, ifail )
		else
			do i1=1,size(a,1)
				write(unit=a_str(i1),fmt="(ES13.5)") a(i1)
				write(unit=b_str(i1),fmt="(ES13.5)") b(i1)
				write(unit=e_str(i1),fmt="(ES13.5)") e(i1)
			end do
			call assert_report( e > epsabs, a_str, b_str, a_name,b_name,filename,line,comment, ifail, &
					extra=e_str, extra_name="abserr" )
		end if
	end subroutine assert_relerr_real_rank1
	subroutine assert_relerr_real_rank2( a, b, epsabs, a_name,b_name,filename,line,comment, ifail )
		real, dimension(:,:), intent(in) :: a,b
		real, intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail
		character(len=13), dimension(size(a,1),size(a,2)) :: a_str, b_str, e_str
		real, dimension(size(a,1),size(a,2)) :: e
		integer :: i1,i2
		if( .not. assert_array_shape( shape(a),shape(b), a_name,b_name,filename,line,comment, ifail ) ) then
			return
		end if
		e = abserr(a,b)
		if( all( e <= epsabs ) ) then
			call assert_success( a_name,b_name,filename,line,comment, ifail )
		else
			do i1=1,size(a,1)
			do i2=1,size(a,2)
				write(unit=a_str(i1,i2),fmt="(ES13.5)") a(i1,i2)
				write(unit=b_str(i1,i2),fmt="(ES13.5)") b(i1,i2)
				write(unit=e_str(i1,i2),fmt="(ES13.5)") e(i1,i2)
			end do
			end do
			call assert_report( e > epsabs, a_str, b_str, a_name,b_name,filename,line,comment, ifail, &
					extra=e_str, extra_name="abserr" )
		end if
	end subroutine assert_relerr_real_rank2
	subroutine assert_relerr_real_double_rank0( a, b, epsabs, a_name,b_name,filename,line,comment, ifail )
		real(kind=kind(1.0d0)), intent(in) :: a,b
		real(kind=kind(1.0d0)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail
		character(len=23) :: a_str, b_str, e_str
		real(kind=kind(1.0d0)) :: e
		e = abserr(a,b)
		if( e <= epsabs ) then
			call assert_success( a_name,b_name,filename,line,comment, ifail )
		else
			write(unit=a_str,fmt="(ES23.16)") a
			write(unit=b_str,fmt="(ES23.16)") b
			write(unit=e_str,fmt="(ES23.16)") e
			call assert_report( e > epsabs, a_str, b_str, a_name,b_name,filename,line,comment, ifail, &
					extra=e_str, extra_name="abserr" )
		end if
	end subroutine assert_relerr_real_double_rank0
	subroutine assert_relerr_real_double_rank1( a, b, epsabs, a_name,b_name,filename,line,comment, ifail )
		real(kind=kind(1.0d0)), dimension(:), intent(in) :: a,b
		real(kind=kind(1.0d0)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail
		character(len=23), dimension(size(a,1)) :: a_str, b_str, e_str
		real(kind=kind(1.0d0)), dimension(size(a,1)) :: e
		integer :: i1
		if( .not. assert_array_shape( shape(a),shape(b), a_name,b_name,filename,line,comment, ifail ) ) then
			return
		end if
		e = abserr(a,b)
		if( all( e <= epsabs ) ) then
			call assert_success( a_name,b_name,filename,line,comment, ifail )
		else
			do i1=1,size(a,1)
				write(unit=a_str(i1),fmt="(ES23.16)") a(i1)
				write(unit=b_str(i1),fmt="(ES23.16)") b(i1)
				write(unit=e_str(i1),fmt="(ES23.16)") e(i1)
			end do
			call assert_report( e > epsabs, a_str, b_str, a_name,b_name,filename,line,comment, ifail, &
					extra=e_str, extra_name="abserr" )
		end if
	end subroutine assert_relerr_real_double_rank1
	subroutine assert_relerr_real_double_rank2( a, b, epsabs, a_name,b_name,filename,line,comment, ifail )
		real(kind=kind(1.0d0)), dimension(:,:), intent(in) :: a,b
		real(kind=kind(1.0d0)), intent(in) :: epsabs
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail
		character(len=23), dimension(size(a,1),size(a,2)) :: a_str, b_str, e_str
		real(kind=kind(1.0d0)), dimension(size(a,1),size(a,2)) :: e
		integer :: i1,i2
		if( .not. assert_array_shape( shape(a),shape(b), a_name,b_name,filename,line,comment, ifail ) ) then
			return
		end if
		e = abserr(a,b)
		if( all( e <= epsabs ) ) then
			call assert_success( a_name,b_name,filename,line,comment, ifail )
		else
			do i1=1,size(a,1)
			do i2=1,size(a,2)
				write(unit=a_str(i1,i2),fmt="(ES23.16)") a(i1,i2)
				write(unit=b_str(i1,i2),fmt="(ES23.16)") b(i1,i2)
				write(unit=e_str(i1,i2),fmt="(ES23.16)") e(i1,i2)
			end do
			end do
			call assert_report( e > epsabs, a_str, b_str, a_name,b_name,filename,line,comment, ifail, &
					extra=e_str, extra_name="abserr" )
		end if
	end subroutine assert_relerr_real_double_rank2


    !--------------------------------------------------------------------------
    ! Miscellaneous
    !--------------------------------------------------------------------------

    function assert_array_shape( shape_a,shape_b, a_name,b_name,filename,line,comment, ifail ) result( equal_shape )
        integer, dimension(:), intent(in) :: shape_a, shape_b
        
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(exception), intent(out), optional :: ifail
        logical :: equal_shape

        character(len=80) :: message

!        if( any(shape(a) /= shape(b)) ) then
!            write(unit=*,fmt="(A,2(I0,A),2(I0,A))") " [!!] Shape differs: shape(a) := ", & 
!                size(a,1), "x", size(a,2), " /= ", size(b,1), "x", size(b,2), " =: shape(b)"
!            return
!        end if

        equal_shape = .false. 
        if( size(shape_a) /= size(shape_b) ) then
            print *, "different rank"
            return
        end if
        if( any(shape_a /= shape_b) ) then
            call assert_fail( a_name,b_name,filename,line,comment, ifail )
            return
        end if
        equal_shape = .true.

    end function assert_array_shape

    function optional_name( a, default ) result( name )
        character(len=*), intent(in), optional :: a, default
        character(len=max(len(a),len(default))) :: name

        if( present(a) ) then
            name = a
        else
            if( present(default) ) then
                name = default
            else
                name = ""
            end if
        end if

    end function optional_name

    function optional_logical( a, default )
        logical, intent(in), optional :: a
        logical, intent(in) :: default
        logical :: optional_logical
        if( present(a) ) then
            optional_logical = a
        else
            optional_logical = default
        end if
    end function optional_logical
    
end module exception_handling_unit_test