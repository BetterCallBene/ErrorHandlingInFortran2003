<?xml version="1.0"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:exsl="http://exslt.org/common" xmlns:str="http://exslt.org/strings">
	<xsl:output omit-xml-declaration="yes"	method="text"/>

	<xsl:variable name="ASSERT_OPTIONS">
		<xsl:text>&#38;
                            a_name,b_name,filename,line,comment, ifail</xsl:text>
	</xsl:variable>
	<xsl:variable name="ASSERT_OPTIONS_PRIMITIVE">
		<xsl:text>&#38;
                            filename,line,comment, ifail</xsl:text>
	</xsl:variable>
    <xsl:variable name="ASSERT_OPTIONS_DECLARATION"><xsl:text/>
        character(len=*), intent(in), optional :: a_name,b_name,filename,comment
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail<xsl:text/>
    </xsl:variable>
    <xsl:variable name="ASSERT_OPTIONS_DECLARATION_PRIMITIVE"><xsl:text/>
        character(len=*), intent(in), optional :: filename,comment
        integer, intent(in), optional :: line
        type(error), intent(out), optional :: ifail<xsl:text/>
    </xsl:variable>
	<xsl:variable name="ASSERT_OPTIONS_TYPEDECLARATION">
        <xsl:text/>character(:), allocatable :: statement, a_name,b_name,extra_name,filename, comment
        integer :: line = -1<xsl:text/>
	</xsl:variable>
	<xsl:template name="assert-options-typeassignment">
		<xsl:param name="condition"/>
            
            ! Populate common info
            info%filename = optional_character( filename, "" )
            info%comment = optional_character( comment, "" )
            info%line = optional_integer( line, -1 )
            
            ! Populate error_info type specific for this rank
            info%statement = "<xsl:value-of select="$condition"/>"
            info%diff = .not. ( <xsl:value-of select="$condition"/> )
            info%a = a_str
            info%b = b_str
            info%a_name = optional_character( a_name, "a" )
            info%b_name = optional_character( b_name, "b" )
            
            ! TODO: check class invariants info
	</xsl:template>
	
	<!-- MAIN -->
	
	<xsl:template match="unittest">
<xsl:text/>! ERROR_HANDLING_UNIT_TEST
! 
!   Collection of wrapper arround commonly used routines that need to check 
!   some condition.
! 
! HISTORY
! 
!   20110217 KP - Initial version
!   20110412 KP - Ported to autogenerated system
!   20111107 KP - Improve reporting
!                 NOTE@self: the distinction between runtime check and unit test test is nice.
!   20111108 KP - Changing the info_message prototype prooved to be a good move for the report functions
!   <xsl:value-of select="$isoD"/> (KP) - Re-generated
! 
! AUTHOR
! 
!   Koen Poppe, Department of Computer Science,
!   Katholieke Universiteit Leuven, Celestijnenlaan 200A,
!   B-3001 Heverlee, Belgium
!   Email: Koen.Poppe@cs.kuleuven.be
!
module error_handling_unit_test
    use error_handling_error
    use design_by_contract
    implicit none
    private
    save
<xsl:text/>

    ! Primitives
    public :: assert
    interface assert
        module procedure assert_logical
    end interface assert
    
    ! Unit testing
    integer, public :: OUTPUT_WIDTH = 80 ! Maximal width of the output
    integer :: ntest = -1, nfail = -1
    character(len=32) :: module_name

    public :: unit_test_reset
    public :: unit_test_results
    public :: write_unit_test_report

    type, extends(dbc_error), public :: unit_test_error
        <xsl:value-of select="$ASSERT_OPTIONS_TYPEDECLARATION"/>
    end type unit_test_error

<xsl:for-each select="exsl:node-set($ranks)/*[ . &lt; 3]">
    type, extends(unit_test_error) :: unit_test_error_rank<xsl:value-of select="."/>
        logical<xsl:call-template name="rank-specification"><xsl:with-param name="rank" select="."/></xsl:call-template><xsl:if test=". &gt; 0">, allocatable</xsl:if> :: diff
        character(:)<xsl:call-template name="rank-specification"><xsl:with-param name="rank" select="."/></xsl:call-template>, allocatable :: a,b, extra
    contains
        procedure :: info_message => unit_test_error_info_message_rank<xsl:value-of select="."/>
    end type unit_test_error_rank<xsl:value-of select="."/>
</xsl:for-each>

    ! Automatic generated
<xsl:call-template name="interfaces"/>
contains<xsl:text/>

    !--------------------------------------------------------------------------
    ! Primitives
    !--------------------------------------------------------------------------

    subroutine assertion_failed()
        
        if( ntest >= 0 ) then
            ntest = ntest + 1
            nfail = nfail + 1
        end if
        
    end subroutine assertion_failed

    subroutine assertion_succeeded()
        
        if( ntest >= 0 ) then
            ntest = ntest + 1
        end if
        
    end subroutine assertion_succeeded
    
    subroutine assert_logical( expression, <xsl:value-of select="$ASSERT_OPTIONS"/> )
        logical, intent(in) :: expression
        <xsl:value-of select="$ASSERT_OPTIONS_DECLARATION"/>
        
        call assert_equal( expression, .true., <xsl:value-of select="$ASSERT_OPTIONS"/> )
    end subroutine assert_logical

    !--------------------------------------------------------------------------
    ! Unit testing
    !--------------------------------------------------------------------------

    ! Reset the test results
    subroutine unit_test_reset(name)
        character(len=*),intent(in), optional :: name
        ntest = 0
        nfail = 0
        module_name = ""
        if( present(name) ) then
            module_name = name
        end if
    end subroutine unit_test_reset

    ! Returns the results of the test so far.
    subroutine unit_test_results(nb_passed,nb_failed,nb_tests)
        integer, intent( out ), optional :: nb_passed, nb_failed, nb_tests
        if( present( nb_passed ) ) nb_passed = ntest-nfail
        if( present( nb_failed ) ) nb_failed = nfail
        if( present( nb_tests  ) ) nb_tests  = ntest
    end subroutine unit_test_results

    ! Write the test report in a fashion compatible to the test warnings.
    subroutine write_unit_test_report()
        integer :: nb_failed, nb_tests
        call unit_test_results(nb_failed=nb_failed, nb_tests=nb_tests)
        if( nb_failed == 0 ) then
            write(unit=*,fmt="(A)",advance="no") "     [OK] "
        else
            write(unit=*,fmt="(A)",advance="no") "     [??] "
        end if
        write(unit=*,fmt="(I0,A,I0,3A)") &amp;
            nb_tests-nb_failed, " of ", nb_tests, " tests passed (", trim(module_name), ")"
    end subroutine write_unit_test_report

    !--------------------------------------------------------------------------
    ! Reporting
    !--------------------------------------------------------------------------

    subroutine report_header( info, unit, prefix, suffix )
        class(unit_test_error), intent(in) :: info
        integer, intent(in) :: unit
        character(len=*), intent(in) :: prefix, suffix
        
        if( len_trim(module_name) > 0 ) then
            write(unit=unit,fmt="(5A)",advance="no") prefix, &amp;
                "[", trim(module_name), "] "
        end if
        
        if( ntest >= 0 ) then
            write(unit=unit,fmt="(A,I0)",advance="no") "Test ", ntest
        else
            write(unit=unit,fmt="(A)",advance="no") "Run-time check"
        end if
        
        if( allocated(info%filename) ) then
            if( len_trim(info%filename) > 0 ) then
                write(unit=unit,fmt="(2A)",advance="no") " in ", info%filename
            end if
        end if
        
        if( info%line > 0 ) then
            write(unit=unit,fmt="(A,I4)",advance="no") "@", info%line
        end if
        
        if( allocated(info%statement) ) then
            if( len_trim(info%statement) > 0 ) then
                write(unit=unit,fmt="(2A)",advance="no") ": ", trim(info%statement)
            end if
        end if
        
        if( allocated(info%comment) ) then
            write(unit=unit,fmt="(3A)",advance="no") " (", trim(info%comment), ")"
        end if
            
        write(unit=unit,fmt="(A)") suffix

    end subroutine report_header
    
    subroutine report_header_nb_differences( unit,prefix,suffix,  nb_diff,nb, recursion )
        integer, intent(in) :: unit
        character(len=*), intent(in) :: prefix, suffix
        integer, intent(in) :: nb_diff, nb
        logical, intent(in), optional :: recursion
        
        if( .not. optional_logical( recursion,.false. ) ) then
            if( nb_diff == nb .and. nb == 1 ) then
                ! Do not report any numbers
            else if( nb_diff == nb ) then
                write(unit=unit,fmt="(2A,I0,2A)") prefix, &amp;
                    "All the ", nb, " elements differ: ", suffix
            else
                write(unit=unit,fmt="(A,I0,A,I0,2A)") prefix, &amp;
                    nb_diff, " of the ", nb, " elements differs: ", suffix
            end if
        end if
        
    end subroutine report_header_nb_differences
    
    subroutine report_details_rank1( info, unit, prefix, suffix, &amp;
            diff, a, b, extra, a_name, b_name,extra_name, idx_row, recursion )
        class(unit_test_error), intent(in) :: info
        integer, intent(in) :: unit
        character(len=*), intent(in) :: prefix, suffix
        logical, dimension(:), intent(in) :: diff
        character(len=*), dimension(:), intent(in) :: a, b
        character(len=*), dimension(:), intent(in), optional :: extra
        character(len=*), intent(in), optional :: a_name, b_name, extra_name
        character(len=*), dimension(:), intent(in), optional :: idx_row
        logical, intent(in), optional :: recursion
    
        integer, dimension(:), allocatable :: diff_idx
        integer :: i,j, w, nb, nb_diff, max_row, row, idx, name_width
        character(len=40) :: fmt_str, la_name, lb_name, trailing, lextra_name
        character(len=3), parameter :: eqs = " = ", sep = " | ", blk = "   "
        character(len=len(blk)) :: sep_or_blk
        character(len=len(a(1))), dimension(size(a)) :: diff_str, the_row
    
        la_name     = optional_allocatable_character( a_name, info%a_name, "a" )
        lb_name     = optional_allocatable_character( b_name, info%b_name, "b" )
        lextra_name = optional_allocatable_character( extra_name, info%extra_name, "" )
        name_width = max(1,len_trim(la_name),len_trim(lb_name),len_trim(lextra_name))
    
        w = len(a(1))
        nb = size(diff)
        nb_diff = count(diff)
        allocate(diff_idx(nb_diff))
        diff_idx = pack( (/ (i,i=1,nb) /), diff )
    
        diff_str = " "
        do i=1,nb_diff
            idx = diff_idx(i)
            do j=1,len(a(idx))
                if( a(idx)(j:j) /= b(idx)(j:j) ) then
                    diff_str(idx)(j:j) = "^"
                else
                    diff_str(idx)(j:j) = "-"
                end if
            end do
        end do
    
        call report_header_nb_differences( unit,prefix,suffix, nb_diff,nb, recursion )

        max_row = (OUTPUT_WIDTH-name_width)/(w+len(sep))
        if( optional_logical( recursion,.false.) .or. (nb &lt;= max_row .and. .not. present(idx_row)) ) then
            if( nb &gt; max_row ) then
                nb = max_row
                write(unit=trailing,fmt="(2A)") sep, "..."
            else
                trailing = ""
            end if
        
            if( nb == 1 ) then
                write(unit=fmt_str,fmt="(2(A,I0),A)") "(A,A",name_width,",A,A",w,",2A)"
            else
                write(unit=fmt_str,fmt="(2(A,I0),A,I0,3A,I0,A)") "(A,A",name_width,",A,A",w,",",nb-1,"('", sep, "',A",w,"),2A)"
            end if
            write(unit=unit,fmt=fmt_str) prefix, trim(la_name), eqs, a(1:nb), trim(trailing), suffix
            write(unit=unit,fmt=fmt_str) prefix, trim(lb_name), eqs, b(1:nb), trim(trailing), suffix

            if( nb == 1 ) then
                write(unit=fmt_str,fmt="(2(A,I0),A)") &amp;
                    "(A,A",name_width+len(eqs),",A",w,",2A)"
            else
                write(unit=fmt_str,fmt="(2(A,I0),A,I0,3A,I0,A)") &amp;
                    "(A,A",name_width+len(eqs),",A",w,",",nb-1,"('", blk, "',A",w,"),2A)"
            end if
            write(unit=unit,fmt=fmt_str) prefix, "", diff_str(1:nb), trim(trailing), suffix
        
            if( present(extra) ) then
                if( nb == 1 ) then
                    write(unit=fmt_str,fmt="(2(A,I0),A)") "(A,A",name_width,",A,A",w,",2A)"
                else
                    write(unit=fmt_str,fmt="(2(A,I0),A,I0,3A,I0,A)") "(A,A",name_width,",A,A",w,",",nb-1,"('", sep, "',A",w,"),2A)"
                end if
                write(unit=unit,fmt=fmt_str) prefix, trim(lextra_name), eqs, extra(1:nb), trim(trailing), suffix
            end if
            return
        end if
    
        max_row = (OUTPUT_WIDTH-name_width-len(eqs))/(w+len(sep))
        do row=0,4
            write(unit=fmt_str,fmt="(2(A,I0),A)") &amp;
                "(A,A",name_width,",A",len(eqs),")"
            sep_or_blk = sep
            select case( row )
                case( 0 ) ! Indexes
                    write(unit=unit,fmt=fmt_str,advance="no") prefix, "idx", eqs
                    if( present( idx_row ) ) then
                        the_row = idx_row
                    else
                        the_row = " "
                        write(unit=fmt_str,fmt="(A,I0,A)") "(I", len(a(1)), ")"
                        do i=1,nb_diff
                            write(unit=the_row(diff_idx(i)),fmt=fmt_str) diff_idx(i)
                        end do
                    end if
                case( 1 )
                    write(unit=unit,fmt=fmt_str,advance="no") prefix, trim(la_name), eqs
                    the_row = a
                case( 2 )
                    write(unit=unit,fmt=fmt_str,advance="no") prefix, trim(lb_name), eqs
                    the_row = b
                case( 3 )
                    write(unit=unit,fmt=fmt_str,advance="no") prefix, "",""
                    the_row = diff_str
                    sep_or_blk = blk
                case( 4 )
                    if( present(extra) ) then
                        write(unit=unit,fmt=fmt_str,advance="no") prefix, lextra_name, eqs
                        the_row = extra
                    else
                        exit
                    end if
            end select
            
            idx = 0
            do i=1,min(nb_diff,max_row)
                if( i&gt;1 ) then
                    write(unit=unit,fmt="(A)",advance="no") sep_or_blk
                end if
            
                ! Elements in between?
                if( diff_idx(i) &gt; idx+1 ) then
                    write(unit=unit,fmt="(2A)",advance="no") ".", sep_or_blk
                end if
            
                ! Element
                idx = diff_idx(i)
                write(unit=unit,fmt="(A)",advance="no") the_row(idx)
            end do
            if( nb_diff &gt; max_row ) then
                write(unit=unit,fmt="(2A)",advance="no") sep_or_blk, " (truncated)"
            else if( diff_idx(min(nb_diff,max_row)) &lt; len(eqs) ) then
                write(unit=unit,fmt="(2A)",advance="no") sep_or_blk, "."
            end if
            write(unit=unit,fmt="(A)",advance="yes") suffix
        end do
    
    end subroutine report_details_rank1

    subroutine report_details_rank2( info, unit, prefix, suffix, &amp;
            diff, a,b,extra, a_name,b_name,extra_name, recursion )
        class(unit_test_error), intent(in) :: info
        integer, intent(in) :: unit
        character(len=*), intent(in) :: prefix, suffix
        logical, dimension(:,:), intent(in) :: diff
        character(len=*), dimension(:,:), intent(in) :: a,b
        character(len=*), dimension(:,:), intent(in), optional :: extra
        character(len=*), intent(in), optional :: a_name, b_name, extra_name
        logical, intent(in), optional :: recursion
    
        character(len=40) :: a_rowstr, b_rowstr, fmt_str
        integer :: row, prev_row
    
        call report_header_nb_differences( unit,prefix,suffix, count(diff),size(diff), recursion ) 
    
        do row=1,size(a,1)
            write(unit=unit,fmt="(A,100L2)",advance="no") prefix, .not. diff(row,:)
            write(unit=unit,fmt="(A)") suffix
        end do
    
        write(unit=fmt_str,fmt="(A,I0,A)") "(2A,I",ceiling(log10(real(size(a,1)))),",A)"
        prev_row = 0
        do row=1,size(a,1)
            if( any(diff(row,:)) ) then
                if( row /= prev_row+1 ) then
                    write(unit=unit,fmt="(3A)") prefix, "(equal rows suppressed)", suffix
                end if
                write(unit=a_rowstr,fmt=fmt_str) trim(optional_allocatable_character(a_name, info%a_name, "a" )), "(", row, ",:)"
                write(unit=b_rowstr,fmt=fmt_str) trim(optional_allocatable_character(b_name, info%b_name, "b" )), "(", row, ",:)"
                if( present(extra) ) then
                    call report_details_rank1( info, unit, prefix, suffix, &amp;
                        diff(row,:), a(row,:),b(row,:), a_name=a_rowstr,b_name=b_rowstr, &amp;
                        recursion=.true., extra=extra(row,:), &amp;
                        extra_name=optional_allocatable_character( extra_name, info%extra_name ) )
                    if( row &lt; size(a,1) ) then
                        write(unit=unit,fmt="(3A)") prefix, repeat("-",len_trim(a_rowstr)), suffix
                    end if
                else
                    call report_details_rank1( info, unit, prefix, suffix, &amp;
                        diff(row,:), a(row,:),b(row,:), a_name=a_rowstr,b_name=b_rowstr, &amp;
                        recursion=.true. )
                end if
                prev_row = row
            end if
        end do
        if( size(a,1) /= prev_row ) then
            write(unit=unit,fmt="(3A)") prefix, "(equal rows suppressed)", suffix
        end if
        
    end subroutine report_details_rank2

    ! Type bound procedures

    subroutine unit_test_error_info_message_rank0( info, unit, prefix, suffix )
        class(unit_test_error_rank0), intent(in) :: info
        integer, intent(in) :: unit
        character(len=*), intent(in) :: prefix, suffix
        
        call report_header( info, unit, prefix, suffix )
        if( allocated(info%extra) ) then ! TODO: better way of doing this?
            call report_details_rank1( info, unit, prefix, suffix, &amp;
                    (/ info%diff /), (/ info%a /), (/ info%b /), (/ info%extra /) )
        else
            call report_details_rank1( info, unit, prefix, suffix, &amp;
                    (/ info%diff /), (/ info%a /), (/ info%b /) )
        end if
        
    end subroutine unit_test_error_info_message_rank0
    
    subroutine unit_test_error_info_message_rank1( info, unit, prefix, suffix )
        class(unit_test_error_rank1), intent(in) :: info
        integer, intent(in) :: unit
        character(len=*), intent(in) :: prefix, suffix
        
        call report_header( info, unit, prefix, suffix )
        if( allocated(info%extra) ) then ! TODO: better way of doing this?
            call report_details_rank1( info, unit, prefix, suffix, &amp;
                    info%diff, info%a, info%b, info%extra )
        else
            call report_details_rank1( info, unit, prefix, suffix, &amp;
                    info%diff, info%a, info%b )
        end if
        
    end subroutine unit_test_error_info_message_rank1
    
    subroutine unit_test_error_info_message_rank2( info, unit, prefix, suffix )
        class(unit_test_error_rank2), intent(in) :: info
        integer, intent(in) :: unit
        character(len=*), intent(in) :: prefix, suffix
        
        call report_header( info, unit, prefix, suffix )
        if( allocated(info%extra) ) then ! TODO: better way of doing this?
            call report_details_rank2( info, unit, prefix, suffix, &amp;
                    info%diff, info%a, info%b, info%extra )
        else
            call report_details_rank2( info, unit, prefix, suffix, &amp;
                    info%diff, info%a, info%b )
        end if
        
    end subroutine unit_test_error_info_message_rank2
    
<xsl:call-template name="procedures"/>

    !--------------------------------------------------------------------------
    ! Miscellaneous
    !--------------------------------------------------------------------------

    recursive function assert_array_shape( shape_a,shape_b, <xsl:value-of select="$ASSERT_OPTIONS"/> ) result( equal_shape )
        integer, dimension(:), intent(in) :: shape_a, shape_b
        <xsl:value-of select="$ASSERT_OPTIONS_DECLARATION"/>
        logical :: equal_shape

!        if( any(shape(a) /= shape(b)) ) then
!            write(unit=unit,fmt="(A,2(I0,A),2(I0,A))") " [!!] Shape differs: shape(a) := ", &amp; 
!                size(a,1), "x", size(a,2), " /= ", size(b,1), "x", size(b,2), " =: shape(b)"
!            return
!        end if

        equal_shape = .false. 
        if( size(shape_a) /= size(shape_b) ) then
            call assert_equal( size(shape_a), size(shape_b), a_name, b_name, filename, line, &amp;
                    optional_character(comment) // "ranks differ", ifail )
            return
        end if
        if( any(shape_a /= shape_b) ) then
            ! Cannot cause infinite recursion because the arrays have the same size
            call assert_equal( shape_a, shape_b, &amp;
                    "shape(" // optional_character(a_name,"a") // ")", &amp;
                    "shape(" // optional_character(b_name,"b") // ")", filename, line, &amp;
                    trim(optional_character(comment)) // " sizes differ", ifail )
            return
        end if
        equal_shape = .true.

    end function assert_array_shape

    function optional_logical( a, default )
        logical, intent(in), optional :: a
        logical, intent(in) :: default
        logical :: optional_logical
        if( present(a) ) then
            optional_logical = a
        else
            optional_logical = default
        end if
    end function optional_logical
    function optional_integer( a, default )
        integer, intent(in), optional :: a
        integer, intent(in) :: default
        integer :: optional_integer
        if( present(a) ) then
            optional_integer = a
        else
            optional_integer = default
        end if
    end function optional_integer
    function optional_character( a, default ) result( name )
        character(len=*), intent(in), optional :: a, default
        character(len=max(len(a),len(default))) :: name

        if( present(a) ) then
            name = a
        else
            if( present(default) ) then
                name = default
            else
                name = ""
            end if
        end if

    end function optional_character
    function optional_allocatable_character( a, b, default ) result( name )
        character(len=*), intent(in), optional :: a, default
        character(:), allocatable, intent(in) :: b
        character(len=40) :: name

        name = ""
        
        if( present(default) ) then
            name = default
        end if
        
        if( allocated(b) ) then
            name = b
        end if
        
        if( present(a) ) then
            if( len_trim(a) > 0 ) then
                name = a
            end if
        end if

    end function optional_allocatable_character

end module error_handling_unit_test<xsl:text/>
	</xsl:template>
	
	<!-- TEMPLATES -->

	<xsl:template match="assert_equal">
		<xsl:param name="version"/>
		<xsl:for-each select="exsl:node-set($version)">
			<xsl:variable name="rank"><xsl:value-of select="@rank"/></xsl:variable>
			<xsl:variable name="is">
				<xsl:for-each select="exsl:node-set($ranks)/*[ 0 &lt; . and . &lt;= $rank]">
					<xsl:text/><xsl:if test=". &gt; 1">,</xsl:if>i<xsl:value-of select="."/><xsl:text/>
				</xsl:for-each>
			</xsl:variable>
			<xsl:variable name="condition">
				<xsl:choose>
					<xsl:when test="@type = 'logical'">
						<xsl:text>a .eqv. b</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>a == b</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
    recursive subroutine <xsl:call-template name="name-mangler"/>( a, b, <xsl:value-of select="$ASSERT_OPTIONS"/> )
        <xsl:value-of select="@type"/><xsl:call-template name="rank-specification"/>, intent(in) :: a,b<xsl:text/>
        <xsl:value-of select="$ASSERT_OPTIONS_DECLARATION"/>
        character(len=<xsl:call-template name="type-width"/>)<xsl:call-template name="rank-specification-equal"/>
        <xsl:text/> :: a_str, b_str<xsl:text/>
        <xsl:if test="$rank &gt; 0"><xsl:text/>
        integer :: <xsl:value-of select="$is"/>
        </xsl:if>
        type(unit_test_error_rank<xsl:value-of select="$rank"/>) :: info
        character(:), allocatable :: statement
        
        <xsl:call-template name="assert-array-shape"/>
        if( <xsl:if test="$rank &gt; 0">all( </xsl:if><xsl:value-of select="$condition"/><xsl:if test="$rank &gt; 0"> )</xsl:if> ) then
            statement = optional_character( a_name, "a" ) // "<xsl:value-of select="$condition"/>" // optional_character( b_name, "b" )
            call assertion_succeeded()
        else<xsl:text/>
            <xsl:choose>
                <xsl:when test="$rank = 0">
            write(unit=a_str,fmt="(<xsl:call-template name="type-format"/>)") a
            write(unit=b_str,fmt="(<xsl:call-template name="type-format"/>)") b<xsl:text/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:for-each select="exsl:node-set($ranks)/*[ 0 &lt; . and . &lt;= $rank]">
            do i<xsl:value-of select="."/>=1,size(a,<xsl:value-of select="."/>)<xsl:text/>
                    </xsl:for-each>
                write(unit=a_str(<xsl:value-of select="$is"/>),fmt="(<xsl:call-template name="type-format"/>)") a(<xsl:value-of select="$is"/>)
                write(unit=b_str(<xsl:value-of select="$is"/>),fmt="(<xsl:call-template name="type-format"/>)") b(<xsl:value-of select="$is"/>)<xsl:text/>
                    <xsl:for-each select="exsl:node-set($ranks)/*[ 0 &lt; . and . &lt;= $rank]">
            end do<xsl:text/>
                    </xsl:for-each>
                </xsl:otherwise>
            </xsl:choose>
            
            <xsl:call-template name="assert-options-typeassignment">
                <xsl:with-param name="condition" select="$condition"/>
            </xsl:call-template>
            
            call assertion_failed()
            call create_error( ifail, info )
        end if
    end subroutine <xsl:call-template name="name-mangler"/>
		</xsl:for-each>
	</xsl:template>
	
	<xsl:template match="abserr">
		<xsl:param name="version"/>
		<xsl:for-each select="exsl:node-set($version)">
			<xsl:variable name="rank"><xsl:value-of select="@rank"/></xsl:variable>
	function <xsl:call-template name="name-mangler"/>( a,b ) result( abs_err )
		<xsl:value-of select="@type"/><xsl:call-template name="rank-specification"/>, intent(in) :: a
		<xsl:value-of select="@type"/><xsl:call-template name="rank-specification-equal"/>, intent(in) :: b
		<xsl:value-of select="@type"/><xsl:call-template name="rank-specification-equal"/> :: abs_err<xsl:text/>
		<xsl:choose>
			<xsl:when test="@rank = 0">
        if( a/=b ) then
            abs_err = abs(a-b)
        else
            abs_err = 0
        end if
			</xsl:when>
			<xsl:otherwise>
        where( a/=b )
            abs_err = abs(a-b)
        elsewhere
            abs_err = 0
        end where
		    </xsl:otherwise>
		</xsl:choose>
	end function <xsl:call-template name="name-mangler"/>
		</xsl:for-each>
	</xsl:template>

	<xsl:template match="assert_abserr">
		<xsl:param name="version"/>
		<xsl:call-template name="assert_err">
			<xsl:with-param name="version" select="$version"/>
			<xsl:with-param name="error_f">abserr</xsl:with-param>
			<xsl:with-param name="err_tol">epsabs</xsl:with-param>
		</xsl:call-template>
	</xsl:template>
	<xsl:template match="assert_relerr">
		<xsl:param name="version"/>
		<xsl:call-template name="assert_err">
			<xsl:with-param name="version" select="$version"/>
			<xsl:with-param name="error_f">abserr</xsl:with-param>
			<xsl:with-param name="err_tol">epsabs</xsl:with-param>
		</xsl:call-template>
	</xsl:template>
	
	<xsl:template name="assert_err">
		<xsl:param name="version"/>
		<xsl:param name="error_f"/>
		<xsl:param name="err_tol"/>
		<xsl:for-each select="exsl:node-set($version)">
			<xsl:variable name="rank"><xsl:value-of select="@rank"/></xsl:variable>
			<xsl:variable name="is">
				<xsl:for-each select="exsl:node-set($ranks)/*[ 0 &lt; . and . &lt;= $rank]">
					<xsl:text/><xsl:if test=". &gt; 1">,</xsl:if>i<xsl:value-of select="."/><xsl:text/>
				</xsl:for-each>
			</xsl:variable>
	subroutine <xsl:call-template name="name-mangler"/>( a, b, <xsl:value-of select="$err_tol"/>, <xsl:value-of select="$ASSERT_OPTIONS"/> )
		<xsl:value-of select="@type"/><xsl:call-template name="rank-specification"/>, intent(in) :: a,b
		<xsl:value-of select="@type"/>, intent(in) :: <xsl:value-of select="$err_tol"/><xsl:text/>
		<xsl:value-of select="$ASSERT_OPTIONS_DECLARATION"/>
		character(len=<xsl:call-template name="type-width"/>)<xsl:text/>
		<xsl:if test="$rank &gt; 0">
			<xsl:text/>, dimension(<xsl:text/>
			<xsl:for-each select="exsl:node-set($ranks)/*[ 0 &lt; . and . &lt;= $rank]">
				<xsl:text/><xsl:if test=". &gt; 1">,</xsl:if>size(a,<xsl:value-of select="."/>)<xsl:text/>
			</xsl:for-each>)<xsl:text/>
		</xsl:if>
		<xsl:text/> :: a_str, b_str, e_str
		<xsl:value-of select="@type"/><xsl:call-template name="rank-specification-equal"/> :: e<xsl:text/>
		<xsl:if test="$rank &gt; 0"><xsl:text/>
		integer :: <xsl:value-of select="$is"/>
		</xsl:if>
		type(unit_test_error_rank<xsl:value-of select="$rank"/>) :: info

		<xsl:call-template name="assert-array-shape"/>
		e = <xsl:value-of select="$error_f"/>(a,b)
		if( <xsl:if test="$rank &gt; 0">all( </xsl:if>e &lt;= <xsl:value-of select="$err_tol"/><xsl:if test="$rank &gt; 0"> )</xsl:if> ) then
			call assertion_succeeded()
		else<xsl:text/>
			<xsl:choose>
				<xsl:when test="$rank = 0">
			write(unit=a_str,fmt="(<xsl:call-template name="type-format"/>)") a
			write(unit=b_str,fmt="(<xsl:call-template name="type-format"/>)") b<xsl:text/>
			write(unit=e_str,fmt="(<xsl:call-template name="type-format"/>)") e<xsl:text/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:for-each select="exsl:node-set($ranks)/*[ 0 &lt; . and . &lt;= $rank]">
			do i<xsl:value-of select="."/>=1,size(a,<xsl:value-of select="."/>)<xsl:text/>
					</xsl:for-each>
				write(unit=a_str(<xsl:value-of select="$is"/>),fmt="(<xsl:call-template name="type-format"/>)") a(<xsl:value-of select="$is"/>)
				write(unit=b_str(<xsl:value-of select="$is"/>),fmt="(<xsl:call-template name="type-format"/>)") b(<xsl:value-of select="$is"/>)
				write(unit=e_str(<xsl:value-of select="$is"/>),fmt="(<xsl:call-template name="type-format"/>)") e(<xsl:value-of select="$is"/>)<xsl:text/>
					<xsl:for-each select="exsl:node-set($ranks)/*[ 0 &lt; . and . &lt;= $rank]">
			end do<xsl:text/>
					</xsl:for-each>
				</xsl:otherwise>
			</xsl:choose>
			
			<xsl:call-template name="assert-options-typeassignment">
                <xsl:with-param name="condition">e &lt;= <xsl:value-of select="$err_tol"/></xsl:with-param>
            </xsl:call-template>
            
            ! Populate additional information
            info%extra = e_str
            info%extra_name = "<xsl:value-of select="$error_f"/>"
            
            call assertion_failed()
            call create_error( ifail, info )
            
		end if
	end subroutine <xsl:call-template name="name-mangler"/>
		</xsl:for-each>
	</xsl:template>


	<xsl:template match="relerr">
		<xsl:param name="version"/>
		<xsl:for-each select="exsl:node-set($version)">
			<xsl:variable name="rank"><xsl:value-of select="@rank"/></xsl:variable>
	function <xsl:call-template name="name-mangler"/>( a,b ) result( rel_err )
		<xsl:value-of select="@type"/><xsl:call-template name="rank-specification"/>, intent(in) :: a
		<xsl:value-of select="@type"/><xsl:call-template name="rank-specification-equal"/>, intent(in) :: b
		<xsl:value-of select="@type"/><xsl:call-template name="rank-specification-equal"/> :: rel_err<xsl:text/>
		<xsl:choose>
			<xsl:when test="@rank = 0">
        if( a/=b ) then
            rel_err = abs((a-b)/a)
        else
            rel_err = 0
        end if
			</xsl:when>
			<xsl:otherwise>
        where( a/=b )
            rel_err = abs((a-b)/a)
        elsewhere
            rel_err = 0
        end where
		    </xsl:otherwise>
		</xsl:choose>

	end function <xsl:call-template name="name-mangler"/>
		</xsl:for-each>
	</xsl:template>
	
	<xsl:template name="assert-array-shape">
		<xsl:if test="@rank &gt; 0"><xsl:text/>
		if( .not. assert_array_shape( shape(a),shape(b), <xsl:value-of select="$ASSERT_OPTIONS"/> ) ) then
			return
		end if<xsl:text/>
		</xsl:if>
	</xsl:template>
	
	<xsl:include href="autogenerated.xsl"/>
	
</xsl:stylesheet>